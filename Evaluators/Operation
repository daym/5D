#ifndef __EVALUATORS_OPERATION_H
#define __EVALUATORS_OPERATION_H
#include <list>
#include "AST/AST"
#include "AST/Keyword"
#include "AST/Symbol"

namespace Evaluators {
typedef std::list<std::pair<AST::NodeT /*keyword*/, AST::NodeT>, gc_allocator<std::pair<AST::NodeT, AST::NodeT> > > CXXArguments;

static inline AST::NodeT internNative(AST::NodeT n) {
	return(n);
}

/* BEGIN str() */

std::string str(AST::NodeT cons);
struct StrRegistration {
	virtual std::string call(AST::NodeT node) const = 0;
};
StrRegistration* registerStr(StrRegistration* n);
#define REGISTER_STR(typ, body) \
struct StrRegistration##typ : Evaluators::StrRegistration { \
	struct StrRegistration* next; \
	StrRegistration##typ(void) { \
		next = Evaluators::registerStr(this); \
	} \
	virtual std::string call(AST::NodeT xxxnode) const { \
		typ* node; \
		if((node = dynamic_cast<typ*>(xxxnode)) != NULL) { \
			body \
		} else if(next) \
			return(next->call(xxxnode)); \
		else \
			return("<node>"); \
	} \
}; \
static StrRegistration##typ fStrRegistration##typ;

/* END str() */

struct CProcedure : AST::Box {
	int fArgumentCount; // sigh. <0: can also do keyword arguments.
	int fReservedArgumentCount; // how many not to repr.
	AST::NodeT /*Symbol**/ fSignature;
        CProcedure(void* native, AST::NodeT aRepr, int aArgumentCount, int aReservedArgumentCount, AST::NodeT /*Symbol**/ aSignature);
};
#define DECLARE_SIMPLE_OPERATION(P) \
extern Evaluators::CProcedure P;

/* for now, builtins don't provide their own signature and so WILL be called with unevaluated arguments */
#define REGISTER_BUILTIN(P, argumentCount, reservedCount, R) Evaluators::CProcedure P((void*) P##_execute, R, argumentCount, reservedCount, NULL);

#define DEFINE_SIMPLE_OPERATION(P, B) \
extern Evaluators::CProcedure P; \
static AST::NodeT P##_execute(AST::NodeT fn, AST::NodeT argument) { \
	return(Evaluators::internNative(B)); \
}

#define DECLARE_FULL_OPERATION(P) DECLARE_SIMPLE_OPERATION(P)
#define DEFINE_FULL_OPERATION(P, B) \
extern Evaluators::CProcedure P; \
static AST::NodeT P##_execute(AST::NodeT fn, AST::NodeT argument) { \
	B; \
}

#define DECLARE_BINARY_OPERATION(P) DECLARE_SIMPLE_OPERATION(P)
#define DEFINE_BINARY_OPERATION(P, B) \
extern Evaluators::CProcedure P; \
static AST::NodeT P##_execute(AST::NodeT fn, AST::NodeT argument) { \
	assert(Evaluators::curried_operation_P(fn)); \
	return(B(Evaluators::get_curried_operation_argument(fn), argument, Evaluators::get_curried_operation_operation(fn))); \
}


/* BEGIN Binary Operations */

bool builtin_call_P(AST::NodeT node);
AST::NodeT call_builtin(AST::NodeT fn, AST::NodeT argument);

/* END Binary Operations */

AST::NodeT repr(AST::NodeT);

/* call this only after all the other arguments have been processed. */
#define FETCH_WORLD(iter) \
	AST::NodeT world = (++iter)->second
#define FETCH_WORLD1(endIter) \
	AST::NodeT world = endIter->second
#define CHANGED_WORLD(value) \
	Evaluators::makeIOMonad(value, world)
#define DECLARE_SPECIAL_FORM(P) DECLARE_SIMPLE_OPERATION(P)
#define DEFINE_BINARY_SPECIAL_FORM(a,b) DEFINE_BINARY_OPERATION(a,b)
#define DEFINE_SPECIAL_FORM(P,v) DEFINE_SIMPLE_OPERATION(P,v)
#define DEFINE_FULL_SPECIAL_FORM(P,body) DEFINE_FULL_OPERATION(P,body)

}; /* end namespace Evaluators */
#endif /* ndef __EVALUATORS_OPERATION_H */
