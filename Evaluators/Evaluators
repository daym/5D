#ifndef __EVALUATORS_H
#define __EVALUATORS_H
#include <set>
#include "AST/AST"
#include "AST/Symbol"
#include "Evaluators/Operation"

namespace Evaluators {
class EvaluationException : public std::exception {
	char* message;
public:
	EvaluationException(const char* s) throw();
	virtual const char* what() const throw();
};

void get_free_variables(AST::Node* root, std::set<AST::Symbol*>& freeNames);
AST::Node* annotate(AST::Node* root);
extern int fGeneration;
static inline bool application_result_P(AST::Node* app) {
	return(((AST::Application*) app)->resultGeneration == fGeneration);
}
AST::Node* reduce1(AST::Node* term);
static inline AST::Node* reduce(AST::Node* term) {
	AST::Application* a;
	if((a = dynamic_cast<AST::Application*>(term)) == NULL)
		return(term);
	else {
		if(application_result_P(term))
			return(((AST::Application*) term)->result);
		else
			return(reduce1(term));
	}
}
AST::Node* close(AST::Symbol* parameter, AST::Node* argument, AST::Node* body);
AST::Node* replace(AST::Node* needle /* not Symbol */, AST::Node* replacement, AST::Node* haystack);/* intended for builtins only */
AST::Node* makeError(const char* reason);
bool define_P(AST::Node* input);
AST::Node* programFromSExpression(AST::Node* root);
AST::Node* evaluate(AST::Node* input);
AST::Cons* evaluateToCons(AST::Node* input);
AST::Node* listFromStr(AST::Str* node);
AST::Node* strFromList(AST::Cons* node);
int increaseGeneration(void);

DECLARE_SIMPLE_OPERATION(Reducer)
DECLARE_SIMPLE_OPERATION(Quoter)

};

#endif /*ndef __EVALUATORS_H*/
