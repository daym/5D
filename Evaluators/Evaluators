#ifndef __EVALUATORS_H
#define __EVALUATORS_H
#include <set>
#include "AST/AST"
#include "AST/Symbol"
#include "Evaluators/Operation"

namespace Evaluators {
class EvaluationException : public std::exception {
	char* message;
public:
	EvaluationException(const char* s) throw();
	virtual const char* what() const throw();
};

static inline AST::Node* throwFallback(const char* text) {
	throw Evaluators::EvaluationException(text);
	return(NULL);
}
#define FALLBACK Evaluators::throwFallback("could not reduce")
/* (AST::Node*) reduce(makeOperation(Symbols::Sspace, fallback, argument))*/

void get_free_variables(AST::Node* root, std::set<AST::Symbol*>& freeNames);
AST::Node* annotate(AST::Node* root);
extern int fGeneration;
static inline bool application_result_P(AST::Node* app) {
	return(((AST::Application*) app)->resultGeneration == fGeneration);
}
AST::Node* reduce1(AST::Node* term);
static inline AST::Node* reduce(AST::Node* term) {
	AST::Application* a;
	if((a = dynamic_cast<AST::Application*>(term)) == NULL)
		return(term);
	else {
		if(application_result_P(term))
			return(((AST::Application*) term)->result);
		else
			return(reduce1(term));
	}
}
AST::Node* close(AST::Symbol* parameter, AST::Node* argument, AST::Node* body);
AST::Node* makeError(const char* reason);
bool define_P(AST::Node* input);
AST::Node* programFromSExpression(AST::Node* root);
AST::Node* evaluate(AST::Node* input);
AST::Cons* evaluateToCons(AST::Node* input);
AST::Node* listFromStr(AST::Str* node);
AST::Node* strFromList(AST::Cons* node);
AST::Node* quote(AST::Node* node);
int increaseGeneration(void);

AST::Node* replace(AST::Node* needle /* not Symbol */, AST::Node* replacement, AST::Node* haystack);/* intended for builtins only */
typedef AST::Node* (replace_predicate_t)(void* userData, AST::Node* node);
AST::Node* mapTree(void* userData, replace_predicate_t* replacer, AST::Node* term);

DECLARE_SIMPLE_OPERATION(Reducer)
DECLARE_SIMPLE_OPERATION(Quoter)
/* BEGIN Curried Operations */

struct CurriedOperation : AST::Node {
	AST::Node* fOperation; /* either CurriedOperation* or CProcedure* */
	AST::Node* fArgument;
	//CurriedOperation(AST::Node* operation, AST::Node* argument) : fOperation(operation), fArgument(argument) {}
};
static inline AST::Node* get_curried_operation_operation(AST::Node* operation) {
	return(((CurriedOperation*)operation)->fOperation);
}
static inline AST::Node* get_curried_operation_argument(AST::Node* operation) {
	return(((CurriedOperation*)operation)->fArgument);
}
CurriedOperation* makeCurriedOperation(AST::Node* operation, AST::Node* argument);
static inline bool curried_operation_P(AST::Node* root) {
	return(dynamic_cast<CurriedOperation*>(root) != NULL);
}

/* END Curried Operations */

static inline AST::Node* uncurried(AST::Node* actualOperation, AST::Node* fallback) {
	return(AST::makeApplication(&Evaluators::Reducer, AST::makeApplication(actualOperation, fallback)));
}
static inline AST::Node* makeIOMonad(AST::Node* result, AST::Node* world) {
	return(AST::makeCons(result, AST::makeCons(world, NULL)));
}

};

#endif /*ndef __EVALUATORS_H*/
