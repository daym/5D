#ifndef __EVALUATORS_H
#define __EVALUATORS_H
#include <set>
#include "AST/AST"
#include "AST/Symbol"

namespace Evaluators {
class EvaluationException : public std::exception {
	char* message;
public:
	EvaluationException(const char* s) throw();
	virtual const char* what() const throw();
};

/*typedef Operation BuiltinOperation;*/
struct BuiltinOperation : AST::Operation { /* FIXME make this string out the fallback, too */
	AST::Node* fallback;
	BuiltinOperation(AST::Node* fallback) {
		this->fallback = fallback;
	}
	virtual bool eager_P() const;
};
struct Reducer : AST::Operation {
	Reducer(void) {}
	virtual bool eager_P(void) const {
		return(true);
	}
	virtual AST::Node* execute(AST::Node* argument);
	virtual std::string str(void) const {
		return("reduce");
	}
};
extern Reducer reducer; /* never EVER make your own instance */

void get_free_variables(AST::Node* root, std::set<AST::Symbol*>& freeNames);
AST::Node* annotate(AST::Node* root);
AST::Node* reduce(AST::Node* term);
AST::Node* close(AST::Symbol* parameter, AST::Node* argument, AST::Node* body);
bool abstraction_P(AST::Node* root);
bool application_P(AST::Node* root);
AST::Node* get_application_operator(AST::Node* root);
AST::Node* get_application_operand(AST::Node* root);
AST::Node* get_abstraction_body(AST::Node* root);
AST::Node* get_abstraction_parameter(AST::Node* root);
AST::Node* application(AST::Node* fn, AST::Node* argument);
AST::Node* abstraction(AST::Node* parameter, AST::Node* body);

};

#endif /*ndef __EVALUATORS_H*/
