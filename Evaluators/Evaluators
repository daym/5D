#ifndef __EVALUATORS_H
#define __EVALUATORS_H
#include <set>
//#include <stdio.h>
#include "AST/AST"
#include "AST/Symbol"
#include "Evaluators/Operation"
#include "AST/HashTable"

namespace Evaluators {
class EvaluationException : public std::exception {
	char* message;
public:
	EvaluationException(const char* s) throw();
	virtual const char* what() const throw();
};

static inline AST::NodeT throwFallback(const char* text) {
	throw Evaluators::EvaluationException(text);
	return(NULL);
}
#define FALLBACK Evaluators::throwFallback("could not reduce")
/* (AST::NodeT) reduce(makeOperation(Symbols::Sspace, fallback, argument))*/

void get_free_variables(AST::NodeT root, AST::HashTable& freeNames);
AST::NodeT annotate(AST::NodeT root);
extern int fGeneration;
static inline bool application_result_P(AST::NodeT app) {
	return(((AST::Application*) app)->resultGeneration == fGeneration);
}
bool quote_P(AST::NodeT root);
extern int recursionLevel;
AST::NodeT reduce1(AST::NodeT term);
static inline AST::NodeT reduce(AST::NodeT term) {
	AST::NodeT result;
	//std::string tv = Evaluators::str(term);
	//fprintf(stderr, "DEBUG: (%d) reducing %s\n", recursionLevel, tv.c_str());
	if(!AST::application_P(term))
		result = term;
	else {
		if(application_result_P(term))
			result = (((AST::Application*) term)->result);
		else
			result = (reduce1(term));
	}
	//std::string rv = Evaluators::str(result);
	//fprintf(stderr, "=> result %s\n", rv.c_str());
	return(result);
}
AST::NodeT close(AST::NodeT /* symbol */ parameter, AST::NodeT argument, AST::NodeT body);
AST::NodeT makeError(const char* reason);
bool define_P(AST::NodeT input);
AST::NodeT programFromSExpression(AST::NodeT root);
AST::NodeT evaluate(AST::NodeT input);
AST::Cons* evaluateToCons(AST::NodeT input);
AST::NodeT quote(AST::NodeT node);
int increaseGeneration(void);

AST::NodeT replace(AST::NodeT needle /* not Symbol */, AST::NodeT replacement, AST::NodeT haystack);/* intended for builtins only */
typedef AST::NodeT (replace_predicate_t)(void* userData, AST::NodeT node);
AST::NodeT mapTree(void* userData, replace_predicate_t* replacer, AST::NodeT term);

DECLARE_SIMPLE_OPERATION(Reducer)
DECLARE_SIMPLE_OPERATION(Quoter)
/* BEGIN Curried Operations */

struct CurriedOperation : AST::Node {
	AST::NodeT fOperation; /* either CurriedOperation* or CProcedure* */
	AST::NodeT fArgument;
	//CurriedOperation(AST::NodeT operation, AST::NodeT argument) : fOperation(operation), fArgument(argument) {}
};
static inline AST::NodeT get_curried_operation_operation(AST::NodeT operation) {
	return(((CurriedOperation*)operation)->fOperation);
}
static inline AST::NodeT get_curried_operation_argument(AST::NodeT operation) {
	return(((CurriedOperation*)operation)->fArgument);
}
CurriedOperation* makeCurriedOperation(AST::NodeT operation, AST::NodeT argument);
static inline bool curried_operation_P(AST::NodeT root) {
	return(dynamic_cast<CurriedOperation*>(root) != NULL);
}

/* END Curried Operations */
static inline bool cons_P(AST::NodeT node) {
	if(pair_P(node)) {
		AST::NodeT snd = AST::get_pair_second(node);
		snd = evaluate(snd);
		return(nil_P(snd) || pair_P(snd));
	} else
		return(false);
}

static inline AST::NodeT uncurried(AST::NodeT actualOperation, AST::NodeT fallback) {
	return(AST::makeApplication(&Evaluators::Reducer, AST::makeApplication(actualOperation, fallback)));
}
static inline AST::NodeT makeIOMonad(AST::NodeT result, AST::NodeT world) {
	return(AST::makeCons(result, AST::makeCons(world, NULL)));
}

};

#endif /*ndef __EVALUATORS_H*/
