#ifndef __5D_BUILTINS_H
#define __5D_BUILTINS_H
#include <sstream>
#include "AST/AST"
#include "AST/Symbols"
namespace Evaluators {
std::string str(AST::Node* cons);
struct StrRegistration {
	virtual std::string call(AST::Node* node) const = 0;
};
StrRegistration* registerStr(StrRegistration* n);
#define REGISTER_STR(typ, body) \
struct StrRegistration##typ : Evaluators::StrRegistration { \
	struct StrRegistration* next; \
	StrRegistration##typ(void) { \
		next = Evaluators::registerStr(this); \
	} \
	virtual std::string call(AST::Node* xxxnode) const { \
		typ* node; \
		if((node = dynamic_cast<typ*>(xxxnode)) != NULL) { \
			body \
		} else if(next) \
			return(next->call(xxxnode)); \
		else \
			return("<node>"); \
	} \
}; \
static StrRegistration##typ fStrRegistration##typ;
};

#include "Numbers/Small"
#include "Numbers/Integer"
#include "Numbers/Real"
#include "AST/Keyword"
#include "AST/Symbol"
#include "Evaluators/Evaluators"


namespace Evaluators {
AST::Node* operator/(const Numbers::Integer& a, const Numbers::Integer& b);
AST::Node* internNative(bool value);
static inline AST::Node* internNative(AST::Node* n) {
	return(n);
}

/* there's a special case in the annotator, so this cannot happen:
AST::SymbolReference* ref = dynamic_cast<AST::SymbolReference*>(argument);
return(ref ? ref->symbol : argument);
*/
DEFINE_UNEAGER_OPERATION(Quoter, "'", argument)
#define DECLARE_CURRIED_OPERATION(P, N) \
struct P : AST::BuiltinOperation { \
	AST::Operation* fParent; \
	AST::Node* fArgument; \
	P(AST::Operation* parent, AST::Node* fallback, AST::Node* argument) : AST::BuiltinOperation(fallback), fParent(parent), fArgument(argument) {} \
	virtual AST::Node* execute(AST::Node* argument); \
};

#define DECLARE_BINARY_OPERATION(P, N) \
	DECLARE_SIMPLE_OPERATION(P, N) \
	DECLARE_CURRIED_OPERATION(Curried ## P, N)

#define FALLBACK (AST::Node*) reduce(makeOperation(Symbols::Sspace, fallback, argument))

DEFINE_SIMPLE_OPERATION(ProcedureP, "procedure?", (dynamic_cast<Operation*>(argument) != NULL))
DECLARE_BINARY_OPERATION(Conser, ":")
DEFINE_SIMPLE_OPERATION(HeadGetter, "head", (dynamic_cast<AST::Cons*>(argument) ? ((AST::Cons*) argument)->head : FALLBACK))
DEFINE_SIMPLE_OPERATION(TailGetter, "tail", (dynamic_cast<AST::Cons*>(argument) ? ((AST::Cons*) argument)->tail : FALLBACK))
DEFINE_SIMPLE_OPERATION(NilP, "nil?", (argument == NULL))
DEFINE_SIMPLE_OPERATION(ConsP, "cons?", (dynamic_cast<AST::Cons*>(argument) != NULL))
DEFINE_SIMPLE_OPERATION(StrP, "str?", str_P(argument))
DEFINE_SIMPLE_OPERATION(SymbolP, "symbol?", symbol_P(argument))
DEFINE_SIMPLE_OPERATION(KeywordP, "keyword?", keyword_P(argument))
DEFINE_SIMPLE_OPERATION(ListFromStringGetter, "listFromStr", (dynamic_cast<AST::Str*>(argument) ? listFromStr((AST::Str*) argument) : FALLBACK))
/*DECLARE_SIMPLE_OPERATION(Int0, "int0")*/
DECLARE_BINARY_OPERATION(Adder, "+")
DECLARE_BINARY_OPERATION(Subtractor, "-")
DECLARE_BINARY_OPERATION(Multiplicator, "*")
DECLARE_BINARY_OPERATION(Divider, "/")
DECLARE_BINARY_OPERATION(SymbolEqualityChecker, "symbolsEqual?")
DECLARE_BINARY_OPERATION(AddrLEComparer, "addrsLE?")
DECLARE_BINARY_OPERATION(LEComparer, "<=")
DECLARE_BINARY_OPERATION(QModulator, "divmod")
DEFINE_SIMPLE_OPERATION(Interner, "symbolFromStr", (dynamic_cast<AST::Str*>(argument) ? AST::symbolFromStr(((AST::Str*)argument)->text.c_str()) : FALLBACK));
DEFINE_SIMPLE_OPERATION(KeywordFromStringGetter, "keywordFromStr", (dynamic_cast<AST::Str*>(argument) ? AST::keywordFromStr(((AST::Str*)argument)->text.c_str()) : FALLBACK))
DEFINE_SIMPLE_OPERATION(KeywordStr, "keywordStr", dynamic_cast<AST::Keyword*>(argument) ? (AST::Node*) AST::makeStr(((AST::Keyword*)argument)->name) : FALLBACK)
DECLARE_SIMPLE_OPERATION(WorldRunner, "internalRunWorld")

/* TODO factorize str here so it returns "(2.3â‹…10**4)" or whatever: */
AST::Node* provide_dynamic_builtins(AST::Node* body);
extern AST::Node* churchFalse;
extern AST::Node* churchTrue;

struct BaseSuperAwareOperation : AST::Operation {
	virtual AST::Node* dummyOperation(void) = 0;
};
template<class T>
struct SuperAwareOperation : BaseSuperAwareOperation { /* will be immediately executed, returns actualOperation but has mutable data which is the super. */
	virtual bool eager_P(void) const {
		return(false);
	}
	SuperAwareOperation(void) {
	}
	virtual AST::Node* dummyOperation(void) {
		return(new T(NULL));
	}
	virtual AST::Node* execute(AST::Node* argument) {
		AST::Operation* actualOperation = new T(argument);
		return(actualOperation);
	}
};

template<class T>
static AST::Node* buildSuperAwareOperation(AST::Symbol* name) {
	return(AST::makeApplication(Symbols::Sreduce, AST::makeApplication(new SuperAwareOperation<T>(), name)));
}

void resetWorld(void);

};

#endif /* ndef __5D_BUILTINS_H */
