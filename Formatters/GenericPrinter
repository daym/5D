void print_CXX(Scanners::OperatorPrecedenceList* OPL, std::ostream& output, int& position, AST::NodeT node, int precedence_limit, bool B_paren_equal_levels) {
	/* the easiest way to think about this is that any and each node has a precedence level. 
	   The precedence level of the atoms is just very high. 
	   The reason it is not explicitly programmed that way is that there are a lot of temporary variables that are used in both precedence level detection and recursion and that would be much code duplication to do two. */
	node = repr(node);
	if(node == NULL)
		print_text(output, position, "[]", false);
	else if(symbol_P(node)) {
		AST::NodeT fAssociativity = NULL;
		int pl = OPL->get_operator_precedence_and_associativity(node, fAssociativity);
		print_text(output, position, AST::get_symbol_name(node), pl != -1 && fAssociativity != Symbols::Sprefix);
	} else if(abstraction_P(node)) { /* abstraction */
		process_abstraction(OPL, output, position, node, precedence_limit, B_paren_equal_levels);
	} else if(application_P(node)) { /* application */
		AST::NodeT envelope = get_application_operator(node);
		if(!application_P(envelope))
			envelope = NULL;
		//if(operator_ && application_P(operator_)) // 2 for binary ops.
		AST::NodeT operator_ = envelope ? get_application_operator(envelope) : NULL;
		AST::NodeT operatorSymbol = repr(operator_);
		if(!symbol1_P(operatorSymbol))
			operatorSymbol = NULL;
		AST::NodeT operatorAssociativity = NULL;
		int precedence = operatorSymbol ? OPL->get_operator_precedence_and_associativity(operatorSymbol, operatorAssociativity) : -1;
		if(precedence != -1 && application_P(envelope)) { // is a (binary) operator and the envelope is not a builtin (i.e. (+))
			bool B_parend = maybe_print_opening_paren(output, position, operator_, precedence, precedence_limit, B_paren_equal_levels);
			print_CXX(OPL, output, position, get_application_operand(envelope), precedence, operatorAssociativity != Symbols::Sleft);
			print_text_raw(output, position, Evaluators::str(operatorSymbol), precedence < OPL->apply_level);
			////print_CXX(OPL, output, position, operator_, precedence, true); // ignored precedence
			AST::NodeT operand = get_application_operand(node);
			if(operatorSymbol == Symbols::Sdot && application_P(operand) && Evaluators::quote_P(get_application_operator(operand))) {
				/* MathParser (Shunting Yard Parser) special cases the dot operator to auto-quote. So auto-unquote here. */
				operand = get_application_operand(operand);
			}
			print_CXX(OPL, output, position, operand, precedence, operatorAssociativity != Symbols::Sright);
			//print_text(output, position, operator_);
			//print_CXX(OPL, output, position, get_application_operand(node), precedence);
			maybe_print_closing_paren(output, position, operator_, B_parend);
		} else { // function application is fine and VERY greedy
			operatorAssociativity = Symbols::Sleft;
			precedence = OPL->apply_level;
			bool B_parend = maybe_print_opening_paren(output, position, operator_, precedence, precedence_limit, B_paren_equal_levels);
			operator_ = get_application_operator(node);
			AST::NodeT xoperatorAssociativity = NULL;
			int xprecedence = symbol1_P(operator_) ? OPL->get_operator_precedence_and_associativity(operator_, xoperatorAssociativity) : -1;
			if(xprecedence != -1 && xoperatorAssociativity != Symbols::Sprefix) { // incomplete binary operation
				++position, output << '(';
				print_text_raw(output, position, Evaluators::str(operator_), precedence < OPL->apply_level);
				++position, output << ')';
			} else
				print_CXX(OPL, output, position, operator_, precedence, operatorAssociativity != Symbols::Sleft);
			if(operator_ != Symbols::Squote)
				print_text_raw(output, position, " ", false);
			print_CXX(OPL, output, position, get_application_operand(node), precedence, operatorAssociativity != Symbols::Sright);
			maybe_print_closing_paren(output, position, operator_, B_parend); // f.e. we now are at +, but came from *, i.e. 2*(3+5)
		}
	} else if(cons_P(node)) {
		int precedence = OPL->apply_level;
		output << "[";
		print_CXX(OPL, output, position, AST::get_cons_head(node), precedence, true);
		AST::NodeT vnode;
		for(vnode = AST::get_cons_tail(node); vnode; vnode = AST::get_cons_tail(vnode)) {
			vnode = Evaluators::evaluate(vnode);
			if(!cons_P(vnode))
				break;
			print_text_raw(output, position, " ", false);
			print_CXX(OPL, output, position, AST::get_cons_head(vnode), precedence, true);
		}
		// TODO certain malformed lists are possible - we kinda support them here since it's bad to lose data, but please don't use them.
		if(!nil_P(vnode)) {
			print_text_raw(output, position, ",", false);
			print_CXX(OPL, output, position, vnode, precedence, true);
		}
		output << "]";
#if 0
	} else if(pair_P(node)) {
		// comma precedence
		AST::NodeT operator_ = Symbols::Scomma;
		AST::NodeT operatorSymbol = Symbols::Scomma;
		AST::NodeT operatorAssociativity = NULL;
		int precedence = operatorSymbol ? OPL->get_operator_precedence_and_associativity(operatorSymbol, operatorAssociativity) : -1;
		bool B_parend = maybe_print_opening_paren(output, position, operator_, precedence, precedence_limit, B_paren_equal_levels);
		print_CXX(OPL, output, position, AST::get_pair_first(node), precedence, operatorAssociativity != Symbols::Sleft);
		print_text_raw(output, position, Evaluators::str(operatorSymbol), precedence < OPL->apply_level);
		////print_CXX(OPL, output, position, operator_, precedence, true); // ignored precedence
		print_CXX(OPL, output, position, AST::get_pair_second(node), precedence, operatorAssociativity != Symbols::Sright);
		maybe_print_closing_paren(output, position, operator_, B_parend);
#endif
	} else if(Numbers::ratio_P(node)) { /* copied from the application_P() case. */
		AST::NodeT operator_ = Symbols::Sslash;
		AST::NodeT operatorAssociativity = NULL;
		int precedence = symbol_P(operator_) ? OPL->get_operator_precedence_and_associativity(operator_, operatorAssociativity) : -1;
		assert(precedence != -1);
		bool B_parend = maybe_print_opening_paren(output, position, operator_, precedence, precedence_limit, B_paren_equal_levels);
		print_CXX(OPL, output, position, Numbers::Ratio_getA(node), precedence, operatorAssociativity != Symbols::Sleft);
		print_text_raw(output, position, Evaluators::str(operator_), precedence < OPL->apply_level);
		////print_CXX(OPL, output, position, operator_, precedence, true); // ignored precedence
		print_CXX(OPL, output, position, Numbers::Ratio_getB(node), precedence, operatorAssociativity != Symbols::Sright);
		maybe_print_closing_paren(output, position, operator_, B_parend);
	} else { /* literal etc */
		/* this especially matches BuiltinOperators which will return their builtin name */
		std::string value = str(node);
		AST::NodeT fAssociativity = NULL;
		int pl = OPL->get_operator_precedence_and_associativity(AST::symbolFromStr(value.c_str()), fAssociativity);
		print_text(output, position, value.c_str(), pl != -1 && fAssociativity != Symbols::Sprefix); // , pl < OPL->apply_level && pl != -1);
	}
}
void print(Scanners::OperatorPrecedenceList* OPL, FILE* output_file, int position, int indentation, AST::NodeT node) {
	std::stringstream sst;
	std::string value;
	print_CXX(OPL, sst, position, node, 0, false);
	value = sst.str();
	fprintf(output_file, "%s", value.c_str());
}
