void print_CXX(Scanners::OperatorPrecedenceList* OPL, std::ostream& output, int& position, AST::Node* node, int precedence_limit, bool B_paren_equal_levels) {
	/* the easiest way to think about this is that any and each node has a precedence level. 
	   The precedence level of the atoms is just very high. 
	   The reason it is not explicitly programmed that way is that there are a lot of temporary variables that are used in both precedence level detection and recursion and that would be much code duplication to do two. */
	node = repr(node);
	AST::Symbol* symbolNode = dynamic_cast<AST::Symbol*>(node);	
	if(node == NULL)
		print_text(output, position, "[]", false);
	else if(symbolNode) {
		AST::Symbol* fAssociativity = NULL;
		int pl = OPL->get_operator_precedence_and_associativity(symbolNode, fAssociativity);
		print_text(output, position, symbolNode->name, pl != -1 && fAssociativity != Symbols::Sprefix);
	} else if(abstraction_P(node)) { /* abstraction */
		process_abstraction(OPL, output, position, node, precedence_limit, B_paren_equal_levels);
	} else if(application_P(node)) { /* application */
		AST::Node* envelope = get_application_operator(node);
		if(!application_P(envelope))
			envelope = NULL;
		//if(operator_ && application_P(operator_)) // 2 for binary ops.
		AST::Node* operator_ = envelope ? get_application_operator(envelope) : NULL;
		AST::Symbol* operatorSymbol = dynamic_cast<AST::Symbol*>(repr(operator_)); 
		AST::Symbol* operatorAssociativity = NULL;
		int precedence = operatorSymbol ? OPL->get_operator_precedence_and_associativity(operatorSymbol, operatorAssociativity) : -1;
		if(precedence != -1 && application_P(envelope)) { // is a (binary) operator and the envelope is not a builtin (i.e. (+))
			bool B_parend = maybe_print_opening_paren(output, position, operator_, precedence, precedence_limit, B_paren_equal_levels);
			print_CXX(OPL, output, position, get_application_operand(envelope), precedence, operatorAssociativity != Symbols::Sleft);
			print_text_raw(output, position, operatorSymbol->str(), precedence < OPL->apply_level);
			////print_CXX(OPL, output, position, operator_, precedence, true); // ignored precedence
			AST::Node* operand = get_application_operand(node);
			if(operatorSymbol == Symbols::Sdot && application_P(operand) && Evaluators::quote_P(get_application_operator(operand))) {
				/* MathParser (Shunting Yard Parser) special cases the dot operator to auto-quote. So auto-unquote here. */
				operand = get_application_operand(operand);
			}
			print_CXX(OPL, output, position, operand, precedence, operatorAssociativity != Symbols::Sright);
			//print_text(output, position, operator_);
			//print_CXX(OPL, output, position, get_application_operand(node), precedence);
			maybe_print_closing_paren(output, position, operator_, B_parend);
		} else { // function application is fine and VERY greedy
			operatorAssociativity = Symbols::Sleft;
			precedence = OPL->apply_level;
			bool B_parend = maybe_print_opening_paren(output, position, operator_, precedence, precedence_limit, B_paren_equal_levels);
			operator_ = get_application_operator(node);
			operatorSymbol = dynamic_cast<AST::Symbol*>(operator_);
			AST::Symbol* xoperatorAssociativity = NULL;
			int xprecedence = operatorSymbol ? OPL->get_operator_precedence_and_associativity(operatorSymbol, xoperatorAssociativity) : -1;
			if(xprecedence != -1 && xoperatorAssociativity != Symbols::Sprefix) { // incomplete binary operation
				++position, output << '(';
                                print_text_raw(output, position, operatorSymbol->str(), precedence < OPL->apply_level);
				++position, output << ')';
			} else
				print_CXX(OPL, output, position, operator_, precedence, operatorAssociativity != Symbols::Sleft);
			if(operatorSymbol != Symbols::Squote)
				print_text_raw(output, position, " ", false);
			print_CXX(OPL, output, position, get_application_operand(node), precedence, operatorAssociativity != Symbols::Sright);
			maybe_print_closing_paren(output, position, operator_, B_parend); // f.e. we now are at +, but came from *, i.e. 2*(3+5)
		}
	} else if(cons_P(node)) {
		output << "[";
		print_CXX(OPL, output, position, ((AST::Cons*)node)->head, 0, false);
		for(AST::Cons* vnode = Evaluators::evaluateToCons(((AST::Cons*)node)->tail); vnode; vnode = Evaluators::evaluateToCons(vnode->tail)) {
			print_text_raw(output, position, " ", false);
			print_CXX(OPL, output, position, dynamic_cast<AST::Cons*>(vnode)->head, 0, false);
		}
		output << "]";
	} else { /* literal etc */
		/* this especially matches BuiltinOperators which will return their builtin name */
		std::string value = str(node);
		AST::Symbol* fAssociativity = NULL;
		int pl = OPL->get_operator_precedence_and_associativity(AST::symbolFromStr(value.c_str()), fAssociativity);
		print_text(output, position, value.c_str(), pl != -1 && fAssociativity != Symbols::Sprefix); // , pl < OPL->apply_level && pl != -1);
	}
}
void print(Scanners::OperatorPrecedenceList* OPL, FILE* output_file, int position, int indentation, AST::Node* node) {
	std::stringstream sst;
	std::string value;
	print_CXX(OPL, sst, position, node, 0, false);
	value = sst.str();
	fprintf(output_file, "%s", value.c_str());
}
