#ifndef __AST_H
#define __AST_H
/*
5D programming language
Copyright (C) 2011  Danny Milosavljevic
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <string>
#include <gc/gc_cpp.h>
#include <gc/gc.h>
#include <gc/gc_allocator.h>
#include <string.h>
static inline char* GCx_strdup(const char* value) {
#ifdef USE_LD_WRAP
	return(strdup(value));
#else
#ifdef GC_STRDUP
	return(GC_STRDUP(value));
#else
	char* result;
	result = (char*) GC_MALLOC_ATOMIC(strlen(value) + 1);
	memcpy(result, value, strlen(value) + 1);
	return(result);
#endif
#endif
}

namespace AST {

struct Node : public gc {
	//virtual std::string str(void) const;
	virtual ~Node(void);
};
struct Cons : Node {
	Node* head;
	Node* tail; /* Cons or Application */
	// FIXME virtual std::string str(void) const;
};
struct Application : Node {
	Node* operator_;
	Node* operand;
	Node* result;
	int resultGeneration;
	//virtual std::string str(void) const;
};
struct Abstraction : Node {
	Node* parameter;
	Node* body;
	//virtual std::string str(void) const;
};
struct Box : Node {
	void* native;
	AST::Node* fRepr;
	Box(void* native, AST::Node* repr) {
		this->native = native;
		this->fRepr = repr;
	}
	//virtual std::string str(void) const;
};
struct Str : Box {
	bool bAtomicity;
	size_t size;
	Str(void* native) :
		Box(native, NULL)
	{
		bAtomicity = false;
	}
	//virtual std::string str(void) const;
};

Cons* makeCons(Node* head, Node* tail);
Str* makeStr(const char* text); // this can contain no pointers
Str* makeStrCXX(const std::string& text, bool bAtomic = false); // this can contain pointers
Str* makeStrRaw(char* mutableText, size_t size, bool bAtomic);
static inline Box* makeBox(void* native, AST::Node* fRepr) {
	return new Box(native, fRepr);
}
bool str_P(AST::Node* node);
static inline bool abstraction_P(Node* root) {
	return(dynamic_cast<Abstraction*>(root) != NULL);
}
static inline bool application_P(Node* root) {
	return(dynamic_cast<Application*>(root) != NULL);
}
static inline Node* get_application_operator(Node* app) {
	return(((Application*)app)->operator_);
}
static inline Node* get_application_operand(Node* app) {
	return(((Application*)app)->operand);
}
static inline Node* get_abstraction_body(Node* abstraction) {
	return(((Abstraction*)abstraction)->body);
}
static inline Node* get_abstraction_parameter(Node* abstraction) {
	return(((Abstraction*)abstraction)->parameter);
}
Application* makeApplication(Node* fn, Node* argument);
Abstraction* makeAbstraction(Node* parameter, Node* body);
Application* makeOperation(Node* operator_, Node* operand_1, Node* operand_2);
static inline bool cons_P(AST::Node* node) {
	return(dynamic_cast<Cons*>(node) != NULL);
}
static inline bool nil_P(AST::Node* node) {
	return(node == NULL);
}


}; /* namespace AST */
#endif /* __AST_H */
