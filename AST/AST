#ifndef __AST_H
#define __AST_H
/*
5D programming language
Copyright (C) 2011  Danny Milosavljevic
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <string>
#include <gc/gc_cpp.h>
#include <gc/gc.h>
#include <gc/gc_allocator.h>
#include <string.h>

namespace AST {

struct Node : public gc {
	//virtual std::string str(void) const;
	virtual ~Node(void);
};
typedef struct Node* NodeT;
struct Cons : Node {
	NodeT tail; /* Cons or Application or something else. */
	NodeT head;
	// FIXME virtual std::string str(void) const;
};
struct Application : Node {
	NodeT operator_;
	NodeT operand;
	NodeT result;
	int resultGeneration;
	//virtual std::string str(void) const;
};
struct Abstraction : Node {
	NodeT parameter;
	NodeT body;
	//virtual std::string str(void) const;
};
struct Box : Node {
	void* native;
	AST::NodeT fRepr;
	explicit Box(void* native, AST::NodeT repr) {
		this->native = native;
		this->fRepr = repr;
	}
	//virtual std::string str(void) const;
};
struct Str : Box {
	bool bAtomicity;
	size_t size;
	explicit Str(void* native) :
		Box(native, NULL)
	{
		bAtomicity = false;
	}
	//virtual std::string str(void) const;
};

Cons* makeCons(NodeT head, NodeT tail);
Str* makeStr(const char* text); // this can contain no pointers
Str* makeStrCXX(const std::string& text, bool bAtomic = false); // this can contain pointers
Str* makeStrRaw(char* mutableText, size_t size, bool bAtomic);
AST::Str* makeStrSlice(AST::Str* s, int offset);
static inline Box* makeBox(void* native, AST::NodeT fRepr) {
	return new Box(native, fRepr);
}
bool str_P(AST::NodeT node);
static inline char* get_str_buffer(AST::NodeT node) {
	return (char*) (((AST::Str*) node)->native);
}
static inline size_t get_str_size(AST::NodeT node) {
	return(((AST::Str*) node)->size);
}
static inline bool get_str_atomic(AST::NodeT node) {
	return(((AST::Str*) node)->bAtomicity);
}
static inline bool abstraction_P(NodeT root) {
	return(dynamic_cast<Abstraction*>(root) != NULL);
}
static inline bool application_P(NodeT root) {
	return(dynamic_cast<Application*>(root) != NULL);
}
static inline NodeT get_application_operator(NodeT app) {
	return(((Application*)app)->operator_);
}
static inline NodeT get_application_operand(NodeT app) {
	return(((Application*)app)->operand);
}
static inline NodeT get_abstraction_body(NodeT abstraction) {
	return(((Abstraction*)abstraction)->body);
}
static inline NodeT get_abstraction_parameter(NodeT abstraction) {
	return(((Abstraction*)abstraction)->parameter);
}
static inline NodeT get_cons_head(NodeT cons) {
	return(((Cons*) cons)->head);
}
static inline NodeT get_cons_tail(NodeT cons) {
	return(((Cons*) cons)->tail);
}
Application* makeApplication(NodeT fn, NodeT argument);
Abstraction* makeAbstraction(NodeT parameter, NodeT body);
Application* makeOperation(NodeT operator_, NodeT operand_1, NodeT operand_2);
static inline bool cons_P(AST::NodeT node) {
	return(dynamic_cast<Cons*>(node) != NULL);
}
static inline bool pair_P(NodeT node) {
	return(dynamic_cast<Cons*>(node) != NULL);
}
static inline bool nil_P(AST::NodeT node) {
	return(node == NULL);
}
static inline AST::NodeT uncacheNodeResult(void* userData, AST::NodeT node) {
	if(application_P(node)) {
		AST::Application* app = dynamic_cast<AST::Application*>(node);
		app->resultGeneration = 0; /* make sure it is not used */
		return(app);
	} else
		return(node);
}
#define nil NULL
static inline AST::NodeT makePair(AST::NodeT a, AST::NodeT b) {
	return(AST::makeCons(a, AST::makeCons(b, nil)));
}
static inline NodeT get_pair_first(NodeT p) {
	return(get_cons_head(p));
}
static inline NodeT get_pair_second(NodeT p) {
	AST::Cons* snd = dynamic_cast<AST::Cons*>(get_cons_tail(p)); // TODO evaluateToCons
	if(!snd)
		return(NULL); // XXX
	return(get_cons_head(snd));
}

}; /* namespace AST */
#endif /* __AST_H */
