#!/usr/bin/env python

import sys

longNames = {
    "p": "void*",
    "i": "int",
    "l": "long",
    "h": "short",
    "L": "long long",
    "d": "double",
    "D": "long double",
    "s": "char*", # for the copying version
    "v": "void",
    "P": "void*", # or null
    "S": "char*", # or null
    "f": "float",
}

def getLongName(c):
    return longNames[c]
    
def checks2(combination):
    result = [combination]
    if combination.startswith("C") and len(combination) == 6:
      c = combination
      while len(c) > 2 and c[-1] == "i":
        c = c[:-1]
        result.append(c)
    return(result)
def checks(combination):
    result = checks2(combination)
    for entry in result:
        if entry[1] == "P":
            result.append(entry[:1] + "p" + entry[2:])
    return(result)

print("""
#include <assert.h>
#include <string.h>
#include "TrampolineSymbols"
#include "Evaluators/Operation"
#include "Evaluators/FFI"
#include "Evaluators/Builtins"
#include "Numbers/Integer"
#include "Numbers/Real"

namespace Trampolines {

static inline AST::Node* extr(const std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& iter) {
  return(iter->second);
}

static inline void* getSomethingUseful(AST::Node* n) {
  AST::Str* s;
  void* result = ((s = dynamic_cast<AST::Str*>(n)) != NULL) ? ((void*) s->text.c_str()) : (Evaluators::get_native_pointer(n));
  if(result == NULL)
    throw Evaluators::EvaluationException("argument is required but empty");
  return(result);
}
static inline void* getSomethingUsefulOrNull(AST::Node* n) {
  if(n == NULL)
     return(NULL);
  else
     return(getSomethingUseful(n));
}
static inline char* strdupOrNull(const char* s) {
  return(s ? strdup(s) : NULL);
}
static inline AST::Node* makeStrOrNil(const char* s) {
  return(s ? AST::makeStr(s) : NULL);
}
static inline AST::Node* makeBoxOrNil(void* s) {
  return(s ? AST::makeBox(s) : NULL);
}
#define unproc iter == end ? NULL : dynamic_cast<Evaluators::CProcedure*>(extr(iter++))
#define unp iter == end ? NULL : getSomethingUseful(extr(iter++))
#define unP iter == end ? NULL : getSomethingUsefulOrNull(extr(iter++))
#define uni iter == end ? 0 : Evaluators::get_native_int(extr(iter++))
#define unl iter == end ? 0 : Evaluators::get_native_long(extr(iter++))
#define unh iter == end ? 0 : Evaluators::get_native_short(extr(iter++))
#define unL iter == end ? 0 : Evaluators::get_native_long_long(extr(iter++))
#define uns iter == end ? NULL : strdup(Evaluators::get_native_string(extr(iter++)))
#define unS iter == end ? NULL : strdupOrNull(Evaluators::get_native_string(extr(iter++)))
#define unf iter == end ? 0 : Evaluators::get_native_float(extr(iter++))
#define unD iter == end ? 0.0L : Evaluators::get_native_long_double(extr(iter++))
#define und iter == end ? 0.0 : Evaluators::get_native_double(extr(iter++))
#define inv
#define inp AST::makeBox(
#define inP makeBoxOrNil(
#define ini Numbers::internNative((Numbers::NativeInt) 
#define inl Numbers::internNative((Numbers::NativeInt) 
#define inh Numbers::internNative((Numbers::NativeInt) 
#define inL Numbers::internNative((long long) 
#define inf Numbers::internNative((Numbers::NativeFloat) 
#define inD Numbers::internNative((long double) 
#define ind Numbers::internNative((double) 
#define ins AST::makeStr(
#define inS makeStrOrNil(
/* FIXME do inL properly */

typedef AST::Node* (jumper_t)(void* p, std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& iter, std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& end);

static HashTable fMarshallers;

""")
combinations = []
for combination in sys.stdin.readlines():
    combination = combination.rstrip("\n")
    combinations.append(combination)
    def getReturner():
       if combination[1] != "v":
          return ("result = in%s" % combination[1]) 
       else:
          return "inv"
    def getCallingConvention(cc):
      if cc == "P":
         return "PASCAL"
      else:
         return ""
    def getFallback():
       if combination[1] == "v":
          return ""
       else:
          return ")"
    def getInliner(combination):
       return("")
    content = combination[1 : ]
    print("typedef %s %s (*proc_%s_t)(%s);" % (getLongName(content[0]), getCallingConvention(combination[0]), combination, ", ".join(map(getLongName, content[1:]))))
    print("""static %(inliner)s AST::Node* jump%(combination)s(void* p, std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& iter, std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& end) {
        proc_%(combination)s_t proc = (proc_%(combination)s_t) p;
        %(tempvariables)s
        AST::Node* result = NULL;
        %(returner)s((*proc)(%(marshallers)s))%(fallback)s;
        return Evaluators::makeIOMonad(result, iter->second); }""" % {
        "combination": combination,
        "tempvariables": "\n        ".join(map(lambda s: "%s a%d = un%s;" % (longNames[s[1]], s[0], s[1]), enumerate(combination[2:]))),
        "inliner": getInliner(combination),
       "marshallers": ", ".join(map(lambda s: "a%d" % s[0], enumerate(combination[2:]))),
       "returner": getReturner(),
       "fallback": getFallback(),
       })
print("""

#undef unP
#undef unp
#undef uni
#undef unl
#undef unh
#undef unL
#undef uns
#undef unS
#undef inP
#undef inp
#undef inP
#undef ini
#undef inl
#undef inh
#undef inL
#undef ins
#undef inS
#undef inf
#undef unf

static void initMarshallers(void) {
""")
for combination in combinations:
    for check in checks(combination):
      #print("	fMarshallers[S_%(check)s->name] = jump%(check)s;" % { "check": check })
      print("	fMarshallers[\"%(check)s\"] = jump%(combination)s;" % { "check": check, "combination": combination })
print("""
} /* end initMarshallers */
""")
print("""
static AST::Node* jumpT(Evaluators::CProcedure* proc, AST::Node* options, AST::Node* world) {
	std::list<std::pair<AST::Keyword*, AST::Node*> > arguments = Evaluators::CXXfromArguments(options, world);
	std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator iter = arguments.begin();
	std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator endIter = arguments.end();
	if(fMarshallers.empty())
        	initMarshallers();
	assert(iter != endIter);
        assert(iter->first == NULL);
	AST::Symbol* signature = proc->fSignature;
	--endIter; /* hide the world */
	HashTable::const_iterator iterMarshaller = fMarshallers.find(signature->name);
	if(iterMarshaller == fMarshallers.end()) {
	    fprintf(stderr, "warning: could not find marshaller for %s\\n", signature->name);
	    return Evaluators::makeIOMonad(NULL, Evaluators::reduce(world));
        } else
            return (*iterMarshaller->second)(proc->native, iter, endIter);
}
       
    
};

#undef unproc
""")
