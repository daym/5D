#!/usr/bin/env python

import sys

longNames = {
    "p": "void*",
    "i": "int",
    "l": "long",
    "h": "short",
    "L": "long long",
    "s": "char*", # for the copying version
    "v": "void",
    "P": "void*", # or null
    "S": "char*", # or null
}

def getLongName(c):
    return longNames[c]
print("""
#include <assert.h>
#include <string.h>
#include "TrampolineSymbols"
#include "Evaluators/Operation"
#include "Evaluators/FFI"
#include "Evaluators/Builtins"
#include "Numbers/Integer"
#include "Numbers/Real"

namespace Trampolines {

static inline AST::Node* extr(const std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& iter) {
  return(iter->second);
}

static inline void* getSomethingUseful(AST::Node* n) {
  AST::Str* s;
  if((s = dynamic_cast<AST::Str*>(n)) != NULL)
     return((void*) s->text.c_str());
  else
     return(Evaluators::get_native_pointer(n));
}
static inline void* getSomethingUsefulOrNull(AST::Node* n) {
  if(n == NULL)
     return(NULL);
  else
     return(getSomethingUseful(n));
}
static inline char* strdupOrNull(const char* s) {
  return(s ? strdup(s) : NULL);
}
static inline AST::Node* makeStrOrNil(const char* s) {
  return(s ? AST::makeStr(s) : NULL);
}
#define unproc iter == end ? NULL : dynamic_cast<Evaluators::CProcedure*>(extr(iter++))
#define unp iter == end ? NULL : getSomethingUseful(extr(iter++))
#define unP iter == end ? NULL : getSomethingUsefulOrNull(extr(iter++))
#define uni iter == end ? 0 : Evaluators::get_native_int(extr(iter++))
#define unl iter == end ? 0 : Evaluators::get_native_long(extr(iter++))
#define unh iter == end ? 0 : Evaluators::get_native_short(extr(iter++))
#define unL iter == end ? 0 : Evaluators::get_native_long_long(extr(iter++))
#define uns iter == end ? NULL : strdup(Evaluators::get_native_string(extr(iter++)))
#define unS iter == end ? NULL : strdupOrNull(Evaluators::get_native_string(extr(iter++)))
#define inv
#define inp AST::makeBox(
#define ini Numbers::internNative((Numbers::NativeInt) 
#define inl Numbers::internNative((Numbers::NativeInt) 
#define inh Numbers::internNative((Numbers::NativeInt) 
#define inL Numbers::internNative((Numbers::NativeInt) 
#define ins AST::makeStr(
#define inS makeStrOrNil(
/* FIXME do inL properly */
""")
combinations = []
for combination in sys.stdin.readlines():
    combination = combination.rstrip("\n")
    combinations.append(combination)
    def getReturner():
       if combination[1] != "v":
          return ("result = in%s" % combination[1]) 
       else:
          return "inv"
    def getCallingConvention(cc):
      if cc == "P":
         return "PASCAL"
      else:
         return ""
    def getFallback():
       if combination[1] == "v":
          return ";"
       else:
          return ")"
    def getInliner(combination):
       return("")
    content = combination[1 : ]
    print("typedef %s %s (*proc_%s_t)(%s);" % (getLongName(content[0]), getCallingConvention(combination[0]), combination, ", ".join(map(getLongName, content[1:]))))
    print("""static %(inliner)s AST::Node* jump%(combination)s(void* p, std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& iter, std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator& end, AST::Node* world) {
        proc_%(combination)s_t proc = (proc_%(combination)s_t) p;
        %(tempvariables)s
        AST::Node* result = NULL;
        %(returner)s((*proc)(%(marshallers)s))%(fallback)s;
        return Evaluators::makeIOMonad(result, /*Evaluators::reduce(*/world/*)*/); }""" % {
        "combination": combination,
        "tempvariables": "\n        ".join(map(lambda s: "%s a%d = un%s;" % (longNames[s[1]], s[0], s[1]), enumerate(combination[2:]))),
        "inliner": getInliner(combination),
       "marshallers": ", ".join(map(lambda s: "a%d" % s[0], enumerate(combination[2:]))),
       "returner": getReturner(),
       "fallback": getFallback(),
       })
print("""

#undef unP
#undef unp
#undef uni
#undef unl
#undef unh
#undef unL
#undef uns
#undef unS
#undef inP
#undef inp
#undef ini
#undef inl
#undef inh
#undef inL
#undef ins
#undef inS

static AST::Node* jumpT(Evaluators::CProcedure* proc, AST::Node* options, AST::Node* world) {
	std::list<std::pair<AST::Keyword*, AST::Node*> > arguments = Evaluators::CXXfromArguments(options, NULL/*world*/);
	std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator iter = arguments.begin();
	std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator endIter = arguments.end();
	assert(iter != endIter);
        assert(iter->first == NULL);
	AST::Symbol* signature = proc->fSignature;
	return """)

def checks(combination):
    result = [combination]
    if combination.startswith("C"):
      c = combination
      while c != "" and c[-1] == "i":
        c = c[:-1]
        result.append(c)
    return(result)
       

for combination in combinations:
    print("  (%(checks)s) ? jump%(combination)s(proc->native, iter, endIter, world) : " % {"checks": " || ".join(map(lambda s: "signature == S_%s" % s, checks(combination))), "combination": combination})
    
print("""
    NULL /* FIXME */;
} /* jumpTrampoline */

};

#undef unproc
""")
