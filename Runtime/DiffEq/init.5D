let Logic := requireModule "Logic" in 
let Composition := requireModule "Composition" in 
let Error := requireModule "Error" in 
let List := requireModule "List" in 
let Arithmetic := requireModule "Arithmetic" in 
import [head tail (:) nan? infinite? nan infinity] from Builtins in 
import [dispatch raiseMissingSymbolError rem rec flip ($) compose (|)] from Composition in 
import [not (&&) (||) if else] from Logic in 
import [(-) (*) (/) (+) (<=) divmod0] from Builtins in 
import [map zipBy] from List in 
import [(+) (-) (*) (/) within round1 round1Log2 (**)] from Arithmetic in 
let repeat := \f rec\repeat \a 
	a:(repeat (f a)) 
in
let easydiff := \f \x \h 
	(f (x + h) - f x)/h
in 
let elimerror := \n rec\elimerror \list
	let a := head list in 
	let b := head (tail list) in 
	((b*(2**n) - a)/(2**n-1)):(elimerror (b:(tail (tail list))))
in
let order := \list 
	let a := head list in 
	let b := head (tail list) in 
	let c := head (tail (tail list)) in 
	round1Log2 ((a - c)/(b - c) - 1)
in 
let improve := \s elimerror (order s) s in 
let diffall := \h0 \f \x 
	let halve := \x x/2 in 
	map (easydiff f x) (repeat halve h0)
in 
let superimprove := \s
	let second := \list head (tail list) in 
	map second (repeat improve s)
in 
let diff := \eps \h0 \f \x 
	diffall h0 f x | superimprove | within eps
in
let easyintegrate := \f \a \b 
	(f a + f b)*(b - a)/2
in 
let integ := \f rec\integ \a \b \fa \fb 
	let m := (a + b)/2 in 
	let fm := f m in 
	((fa + fb)*(b - a)/2):(zipBy (+) (integ a m fa fm) (integ m b fm fb))
in 
let integrateall := \f \a \b 
	integ f a b (f a) (f b)
in 
let integrate := \eps \f \a \b
	integrateall f a b | within eps
in 
(requireModule "Composition").dispatch1 (#exports[easydiff diff integrate])
