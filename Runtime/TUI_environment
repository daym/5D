(((((REPLV1 textBufferText) "223 + 2
223 + 25
223 + 256
2.3 + 4
2.3 + 4 + 1
2.3 + 4 + 1 + 2
if
id
define id \\f f
define if id
define else id
define otherwise id
5 + 5
flip
define flip \\f \\a \\b f b a
define compose \\f \\g \\x f (g x)
define (|) \\a \\b b a
define toBool \\v if (v) 't 'f
define Y \\f (\\x f (x x)) (\\x f (x x))
define rec Y
5 + 5
define (&&) \\a \\b \\t \\f a (b t f) f
define (||) \\a \\b \\t \\f a t (b t f)
define not \\v \\t \\f v f t
define implies \\a \\b (not a) || b
define equivalent? \\a \\b (a&&b) || ((not a) && (not b))
2<3
define (<) \\a \\b a <= b && not (b <= a)
2 < 3
2 < 3 | toBool 
define (>) flip (<)
define (=) \\a \\b a <= b && b <= a
define (/=) \\a \\b not (a=b)
<
>
<=
>=
define (>=) \\a \\b b <= a
>=
define (≤) <=
define (≥) (>=)
2%3
2⋅3
divmod
divmod 1 2
div
define div \\a \\b (divmod a b) |head
div 1 2
define mod \\a \\b (divmod a b) |tail | head
mod 1 2
define (%) mod
2%3
monadWorld
define monadWorld \\m m | tail | head
define monadLift \\v \\world [v world]
monadLift 42
define lift monadLift
define monadValue \\m head m
runWorld (lift 42)
runWorld
define runWorld monadValue (internalRunWorld2 42)
runWorld (lift 42)
define runWorld \\m monadValue (internalRunWorld2 m 42)
runWorld (lift 42)
internalRunWorld2 
internalRunWorld2 1
internalRunWorld2 
define runWorld \\m monadValue (internalRunWorld2 m)
runWorld (lift 42)
;
define (;) \\a \\ber \\world let r=(a world) in (ber (monadValue r) (monadWorld r))
runWorld (lift 42 ;\\v lift v)
runWorld (lift 42 ;\\v lift 32)
32 + 5
define rangeLL \\step \\end if (step > 0) (rec \\rangeLL \\beginning if(beginning >= end) nil (beginning:(rangeLL (beginning + step)))) (rec \\rangeLL \\end \\beginning if(beginning <= end) nil (beginning:(rangeLL (beginning + step))))
rangeLL 1 10 0
rangeLL 1 20 0
rangeLL 1 50 0
rangeLL 1 100 0
rangeLL 1 300 0
rangeLL 1 1000 0
rangeLL 1 999 0
rangeLL 1 500 0
rangeLL 1 400 0
rangeLL 1 300 0
rangeLL 1 350 0
rangeLL 1 320 0
rangeLL 1 310 0
rangeLL 1 300 0
rangeLL 1 (-1) (-299)
rangeLL (-1) (-1) (-299)
define rangeLL \\step \\end if (step > 0) (rec \\rangeLL \\beginning if(beginning >= end) nil (beginning:(rangeLL (beginning + step)))) (rec \\rangeLL \\beginning if(beginning <= end) nil (beginning:(rangeLL (beginning + step))))
rangeLL (-1) (-1) (-299)
rangeLL (-1) (-1) (299)
define range1 \\beginning \\end rangeLL 1 end beginning
range1 1 10
define length rec \\length \\list if (nil? list) 0 1 + (length (tail list))
length [1 2 3]
define length rec \\length \\list if (nil? list) 0 (1 + (length (tail list)))
length [1 2 3]
length [3]
length []
define foldr \\folder \\v rec \\foldr \\list if (nil? list) v (folder (head list) (foldr (tail list)))
foldr (+) 0 [1 2 3]
foldr (-) 0 [1 2 3]
define foldl \\folder rec \\foldr \\v \\list if (nil? list) v (foldl (folder v (head list)) (tail list))
foldl (+) 0 [1 2 3]
define foldl \\folder rec \\foldl \\v \\list if (nil? list) v (foldl (folder v (head list)) (tail list))
foldl (+) 0 [1 2 3]
foldl (-) 0 [1 2 3]
define map \\f \\list foldr (compose (:) f) [] list
map (\\x x*2) [1 2 3]
range 0 10 1
define range \\beginning \\end \\step rangeLL step end beginning
range 0 101 
range 0 10 1 
define zipWith \\zipper \\l1 \\l2 if (nil? l1) nil \\
define ($) id
define zipWith \\zipper rec \\zipWith \\l1 \\l2 if (nil? l1) nil $else if (nil? l2) nil $else (zipper (head l1) (head l2)):(zipWith (tail l1) (tail l2))
zipWith (:) [1 2 3] [4 5 6]
zipWith (\\a \\b [a b]) [1 2 3] [4 5 6]
zipWith (\\a \\b [a b]) [1 2 3] [4 5]
zipWith (\\a \\b [a b]) [1 2 3] []
define zip \\l1 \\l2 zipWith (\\a \\b [a b]) l1 l2
zip [1 2 3] [4 5]
foldl (flip (:)) [] [1 2 3]
define reverse \\list foldl (flip (:)) [] list
define take rec \\take \\count \\list if (count <= 0) [] $else (head list):(take (count - 1) (tail list))
take 2 [5 6 7 8]
take 0 [5 6 7 8]
take (-2) [5 6 7 8]
define drop rec \\drop \\count \\list if (count <= 0) list $else (drop (count - 1) (tail list))
drop 0 [5 6 7 8]
drop 1 [5 6 7 8]
drop (-7) [5 6 7 8]
drop 5 [5 6 7 8]
drop 4 [5 6 7 8]
drop 3 [5 6 7 8]
drop 2 [5 6 7 8]
drop 1 [5 6 7 8]
(foldr (:) [] [5 6 7 8])
(foldr (\\x \\y (if (x>6) (:) id) x y) [] [5 6 7 8])
(foldr (\\x \\y (if (x>6) (:) (\\a \\b b)) x y) [] [5 6 7 8])
(foldr (\\x \\y (if (x<6) (:) (\\a \\b b)) x y) [] [5 6 7 8])
(foldr (\\x \\y (if (x<6 || x > 7) (:) (\\a \\b b)) x y) [] [5 6 7 8])
define filter \\f \\list foldr (\\x \\y (if (f x) (:) (\\a \\b b)) x y) [] list
filter (\\x x<6) [5 6 7 8]
filter (\\x x<6||x>7) [5 6 7 8]
define mergeWith \\lessEqualComparator \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (not (nil? l1) && lessEqualComparator (head l1) (head l2)))
define mergeWith \\lessEqualComparator rec \\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (not (nil? l1) && lessEqualComparator (head l1) (head l2))) (head l1):(mergeWith (tail l1) l2)) $else (head l2:(mergeWith l1 (tail l2)))
define mergeWith \\lessEqualComparator rec \\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (not (nil? l1) && lessEqualComparator (head l1) (head l2))) (head l1):(mergeWith (tail l1) l2)) $else (head l2:(mergeWith l1 (tail l2))
define mergeWith \\lessEqualComparator rec \\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (not (nil? l1) && lessEqualComparator (head l1) (head l2))) (head l1):(mergeWith (tail l1) l2)) $else (head l2:(mergeWith l1 (tail l2)))
define mergeWith \\lessEqualComparator rec \\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (not (nil? l1) && lessEqualComparator (head l1) (head l2))) (head l1):(mergeWith (tail l1) l2) $else (head l2:(mergeWith l1 (tail l2)))
mergeWith (<=) [2 3 4] [4 5]
mergeWith (<=) [2 3 4 7 8] [4 5 6 9 10]
define merge mergeWith (<=)
merge [2 3 4 7 8] [4 5 6 9 10]
5 + 5
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith take (div (length list) 2))
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith take (div (length list) 2)) (mergeSortWith drop (div (length list) 2))
mergeSortWith (<=) [5 4 3 2 1]
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
mergeSortWith (<=) [5 4 3 2 1]
take 5 [2 3 4]
drop 5 [2 3 4]
define take rec \\take \\count \\list if (count <=  || nil? list0) [] $else (head list):(take (count - 1) (tail list))
define drop rec \\drop \\count \\list if (count <=  || nil? list0) list $else (drop (count - 1) (tail list))
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
mergeSortWith (<=) [5 4 3 2 1]
drop 2 []
define drop rec \\drop \\count \\list if (count <= 0 || nil? list) list $else (drop (count - 1) (tail list))
define take rec \\take \\count \\list if (count <= 0 || nil? list) [] $else (head list):(take (count - 1) (tail list))
drop 2 []
mergeSortWith (<=) [5 4 3 2 1]
mergeSortWith (<=) [5 4 3 2 1]
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
mergeSortWith (<=) [5 4 3 2 1]
5 + 3
5 + 3⋅4
5 + 3⋅4⋅2
5 + 3⋅4⋅9999
mergeSortWith (<=) [5 4 3 2 1]
mergeSortWith (<=) [1]
mergeSortWith (<=) [1 2]
mergeSortWith (<=) [1 2 34]
mergeSortWith (<=) [1 2 3]
mergeSortWith (<=) [1 3 2]
(\\list (take (div (length list) 2) list)) [1 3 2]
(\\list (drop (div (length list) 2) list)) [1 3 2]
#info mergeWith
mergeSortWith (<=) [5 4 3 2 1]
mergeSortWith (<=) [1 2 3 4 5]
#info mergeWith
define mergeWith \\lessEqualComparator rec \\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (not (nil? l1) && lessEqualComparator (head l1) (head l2))) (head l1):(mergeWith (tail l1) l2) $else (head l2:(mergeWith l1 (tail l2)))
define mergeWith \\lessEqualComparator rec \\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil (if (nil? l2 || (not (nil? l1) && (lessEqualComparator (head l1) (head l2)))) (head l1):(mergeWith (tail l1) l2) (head l2:(mergeWith l1 (tail l2))))
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
mergeSortWith (<=) [1 2 3 4 5]
mergeSortWith (<=) [5 4 3 2 1]

define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
define mergeWith \\\\lessEqualComparator rec (\\\\merge \\\\l1 \\\\l2 if (nil? l1 && nil? l2) nil (if (nil? l2) (head l1):(merge (tail l1) l2) (if (nil? l1) (h
ead l2):(merge l1 (tail l2)) (if (lessEqualComparator (head l1) (head l2)) (head l1):(merge (tail l1) l2) (head l2):(merge l1 (tail l2))))))
define mergeWith \\\\lessEqualComparator rec (\\\\merge \\\\l1 \\\\l2 if (nil? l1 && nil? l2) nil (if (nil? l2) (head l1):(merge (tail l1) l2) (if (nil? l1) (head l2):(merge l1 (tail l2)) (if (lessEqualComparator (head l1) (head l2)) (head l1):(merge (tail l1) l2) (head l2):(merge l1 (tail l2))))))
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
mergeSortWith (<=) [5 4 3 2 1]
define mergeWith \\lessEqualComparator rec (\\merge \\l1 \\l2 if (nil? l1 && nil? l2) nil (if (nil? l2) (head l1):(merge (tail l1) l2) (if (nil? l1) (head l2):(merge l1 (tail l2)) (if (lessEqualComparator (head l1) (head l2)) (head l1):(merge (tail l1) l2) (head l2):(merge l1 (tail l2))))))
define mergeSortWith \\lessEqualComparator rec \\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
mergeSortWith (<=) [5 4 3 2 1]
mergeSortWith (<=) [5 4 3 2 1]
mergeSortWith (<=) [5 4 3 2 1]
define mergeSort \\list (mergeSortWith (<=) list)
mergeSort
mergeSort [5 4 3 2 1]
") environment) ((\id ((\if ((\else ((\otherwise ((\flip ((\compose ((\| ((\toBool ((\Y ((\rec ((\&& ((\|| ((\not ((\implies ((\equivalent? ((\< ((\> ((\= ((\/= ((\>= ((\≤ ((\≥ ((\div ((\mod ((\% ((\monadWorld ((\monadLift ((\lift ((\monadValue ((\runWorld ((\runWorld ((\runWorld ((\; ((\rangeLL ((\rangeLL ((\range1 ((\length ((\length ((\foldr ((\foldl ((\foldl ((\map ((\range ((\$ ((\zipWith ((\zip ((\reverse ((\take ((\drop ((\filter ((\mergeWith ((\mergeWith ((\merge ((\mergeSortWith ((\mergeSortWith ((\mergeSortWith ((\take ((\drop ((\mergeSortWith ((\drop ((\take ((\mergeSortWith ((\mergeWith ((\mergeWith ((\mergeSortWith ((\mergeSortWith ((\mergeWith ((\mergeSortWith ((\mergeWith ((\mergeSortWith ((\mergeSort nil) (\list ((mergeSortWith <=) list)))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator (rec (\merge (\l1 (\l2 (((if ((&& (nil? l1)) (nil? l2))) nil) (((if (nil? l2)) ((: (head l1)) ((merge (tail l1)) l2))) (((if (nil? l1)) ((: (head l2)) ((merge l1) (tail l2)))) (((if ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((merge (tail l1)) l2))) ((: (head l2)) ((merge l1) (tail l2)))))))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (\\ ((lessEqualComparator rec) (\\ (merge (\\ (l1 (\\ ((((l2 if) ((&& (nil? l1)) (nil? l2))) nil) (((if (nil? l2)) ((: (head l1)) ((merge (tail l1)) l2))) (((if (nil? l1)) ((: (head l2)) ((merge l1) (tail l2)))) (((if ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((merge (tail l1)) l2))) ((: (head l2)) ((merge l1) (tail l2)))))))))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (((if ((&& (nil? l1)) (nil? l2))) nil) (((if ((|| (nil? l2)) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2))))) ((: (head l1)) ((mergeWith (tail l1)) l2))) (head ((: l2) ((mergeWith l1) (tail l2))))))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) ((|| (nil? l2)) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2))))) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (else (head ((: l2) ((mergeWith l1) (tail l2)))))))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (rec (\take (\count (\list (($ ((if ((|| ((<= count) 0)) (nil? list))) nil)) (else ((: (head list)) ((take ((- count) 1)) (tail list))))))))))) (rec (\drop (\count (\list (($ ((if ((|| ((<= count) 0)) (nil? list))) list)) (else ((drop ((- count) 1)) (tail list)))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (rec (\drop (\count (\list (($ ((if ((<= count) ((|| nil?) list0))) list)) (else ((drop ((- count) 1)) (tail list)))))))))) (rec (\take (\count (\list (($ ((if ((<= count) ((|| nil?) list0))) nil)) (else ((: (head list)) ((take ((- count) 1)) (tail list))))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) ((mergeSortWith take) ((div (length list)) 2))) ((mergeSortWith drop) ((div (length list)) 2)))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) (((else mergeWith) lessEqualComparator) ((mergeSortWith take) ((div (length list)) 2)))))))))) (mergeWith <=))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) ((|| (nil? l2)) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2))))) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (else (head ((: l2) ((mergeWith l1) (tail l2)))))))))))))) (\lessEqualComparator (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) ((else if) ((|| (nil? l2)) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2))))))))))) (\f (\list (((foldr (\x (\y (((((if (f x)) :) (\a (\b b))) x) y)))) nil) list))))) (rec (\drop (\count (\list (($ ((if ((<= count) 0)) list)) (else ((drop ((- count) 1)) (tail list)))))))))) (rec (\take (\count (\list (($ ((if ((<= count) 0)) nil)) (else ((: (head list)) ((take ((- count) 1)) (tail list))))))))))) (\list (((foldl (flip :)) nil) list)))) (\l1 (\l2 (((zipWith (\a (\b ((: a) ((: b) nil))))) l1) l2))))) (\zipper (rec (\zipWith (\l1 (\l2 (($ ((if (nil? l1)) nil)) (($ (((else if) (nil? l2)) nil)) (else ((: ((zipper (head l1)) (head l2))) ((zipWith (tail l1)) (tail l2))))))))))))) id)) (\beginning (\end (\step (((rangeLL step) end) beginning)))))) (\f (\list (((foldr ((compose :) f)) nil) list))))) (\folder (rec (\foldl (\v (\list (((if (nil? list)) v) ((foldl ((folder v) (head list))) (tail list)))))))))) (\folder (rec (\foldr (\v (\list (((if (nil? list)) v) ((foldl ((folder v) (head list))) (tail list)))))))))) (\folder (\v (rec (\foldr (\list (((if (nil? list)) v) ((folder (head list)) (foldr (tail list))))))))))) (rec (\length (\list (((if (nil? list)) 0) ((+ 1) (length (tail list))))))))) (rec (\length (\list ((+ (((if (nil? list)) 0) 1)) (length (tail list)))))))) (\beginning (\end (((rangeLL 1) end) beginning))))) (\step (\end (((if ((> step) 0)) (rec (\rangeLL (\beginning (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))) (rec (\rangeLL (\beginning (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (\step (\end (((if ((> step) 0)) (rec (\rangeLL (\beginning (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))) (rec (\rangeLL (\end (\beginning (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))))))))))) (\a (\ber (\world ((\r ((ber (monadValue r)) (monadWorld r))) (a world))))))) (\m (monadValue (internalRunWorld2 m))))) (\m (monadValue ((internalRunWorld2 m) 42))))) (monadValue (internalRunWorld2 42)))) (\m (head m)))) monadLift)) (\v (\world ((: v) ((: world) nil)))))) (\m ((| ((| m) tail)) head)))) mod)) (\a (\b ((| ((| ((divmod a) b)) tail)) head))))) (\a (\b ((| ((divmod a) b)) head))))) >=)) <=)) (\a (\b ((<= b) a))))) (\a (\b (not ((= a) b)))))) (\a (\b ((&& ((<= a) b)) ((<= b) a)))))) (flip <))) (\a (\b ((&& ((<= a) b)) (not ((<= b) a))))))) (\a (\b ((|| ((&& a) b)) ((&& (not a)) (not b))))))) (\a (\b ((|| (not a)) b))))) (\v (\t (\f ((v f) t)))))) (\a (\b (\t (\f ((a t) ((b t) f)))))))) (\a (\b (\t (\f ((a ((b t) f)) f))))))) Y)) (\f ((\x (f (x x))) (\x (f (x x))))))) (\v (((if v) (' t)) (' f))))) (\a (\b (b a))))) (\f (\g (\x (f (g x))))))) (\f (\a (\b ((f b) a)))))) id)) id)) id)) (\f f))) nil)