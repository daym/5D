(((((REPLV1 textBufferText) "5 + 2
5 + 5
5 + 5⋅3
f
f x + g x
\\f \\g \\x (f x + g x)
\\f \\g \\x (f x + g x) 'f 'g 'x
(\\f \\g \\x (f x + g x)) 'f 'g 'x
int0 
intSucc int0 
integerSucc int0 
(
(
)
div 5 0
divmod 5 0
5 + 5
5 + 5⋅100
define if \\f f
define id \\f f
define else id
define otherwise id
define ($) \\a \\b a b
if (2 < 3) 't 'f
define (<) \\a \\b (a <= b) && not (b <= a)
define (&&) \\a \\b \\t \\f a (b t f) f
define (||) \\a \\b \\t \\f a t (b t f)
define not \\a \\t \\f a f t
define (<) \\a \\b (a <= b) && not (b <= a)
define flip \\f \\a \\b f b a
define (>) flip (<)
1<2
if (1 < 2) 't 'f
define foldr \\f \\v rec \\foldr \\list if (nil? list) v $else f (head list) (foldr (tail list))
define Y \\f (\\x f (x x)) (\\x f (x x))
define rec Y
define foldr \\f \\v rec \\foldr \\list if (nil? list) v $else f (head list) (foldr (tail list))
if (1 < 2) 't 'f
foldr (+) 0 [1 2 3]
define foldl \\f rec\\foldl \\v \\list if (nil? list) v $else foldl (f (head list) v) (tail list) 
foldl (+) 0 [1 2 3]
define compose \\f \\g \\x f (g x)
define map \\f \\list (foldr (compose (:) f) [] list)
map (\\x x*2) [1 2 3]
define (++) \\a \\b foldr (:) b a
[1 2 3] ++ [4 5 6]
1=2
define (=) \\a \\b (a <= b) && (b <= a)
1=1
if (1=1) 't 'f
δ
define δ \\x if (x = 0) 1 0
δ 0
δ 1
δ (2-2)
filter
define reverse \\list (foldl (flip (:)) [] list)
reverse (listFromStr \"hello\")
define foldl \\f rec\\foldl \\v \\list if (nil? list) v $else foldl (f v (head list)) (tail list) 
define reverse \\list (foldl (flip (:)) [] list)
reverse (listFromStr \"hello\")
strFromList (reverse (listFromStr \"hello\"))
reverse (listFromStr \"hello\") |strFromList
define (|) \\a \\b b a
reverse (listFromStr \"hello\") |strFromList
id
if
else
flip
rec
otherwise
compose
toBool
|
&&
||
not
implies?
equivalent?
<
=
>
define (/=) \\a \\b not (a = b)
>=
define (>=) \\a \\b (b <= a)
if (5 >= 2) 't 'f
define (≤) <=
define (≥) (>=)
define div \\a \\b head (divmod a b)
define mod \\a \\b head (tail (divmod a b))
mod 5 2
define (%) mod
define monadWorld \\m head (tail m)
define monadValue \\m head m
define monadLift \\v \\world [v world]
define lift monadLift
define runWorld \\m monadValue (unsafeRunWorld2 m)
runWorld (lift 2)
runWorld (lift 42)
filter
foldl
foldr
range
take
drop
define (;) \\m \\ber \\world let r = (m world) in ber (monadValue r) (monadWorld r)
runWorld (lift 42 ;\\v lift 2)
runWorld (lift 42 ;\\v lift (2 + v))
define implies? \\a \\b (not a || b)
if (implies? #t #f) 't 'f
if (implies? #f #f) 't 'f
if (implies? #f #t) 't 'f
if (implies? #t #t) 't 'f
define equivalent? \\a \\b (a && b) || ((not a) && (not b))
equivalent? 
define take rec\\take \\count \\list if (count <= 0 || nil? list) nil (head list):(take (count - 1) (tail list))
take 2 [3 4 5]
take 5 [3 4 5]
take (-1) [3 4 5]
define drop rec\\drop \\count \\list if (count <= 0 || nil? list) list (drop (count - 1) (tail list))
drop 2 [3 4 5]
drop 200 [3 4 5]
drop 3 [3 4 5]
drop 1 [3 4 5]
drop 0 [3 4 5]
drop (-1) [3 4 5]
[3 4 5] ++ [6]
filter
foldl
foldr
range
define rangeLL \\step \\end rec\\rangeLL \\beginning if (step <= (-1)) (if (beginning <= end) nil beginning:(rangeLL (beginning + step))) (if (beginning >= end) nil beginning:(rangeLL (beginning + step)))
rangeLL 1 0 10
define rangeLL \\step \\end rec\\rangeLL \\beginning if (step <= (-1)) (if (beginning <= end) nil (beginning:(rangeLL (beginning + step)))) (if (beginning >= end) nil (beginning:(rangeLL (beginning + step))))
rangeLL 1 0 10
rangeLL 1 10 0
rangeLL 1 10 0
define range \\beginning \\end \\step (rangeLL step end beginning)
range 0 10 1
range 0 10 (-1)
range 9 (-1) (-1)
define range1 \\beginning \\end rangeLL 1 end beginning
range1 1 10
zipWith
define zipWith \\zipper rec\\zipWith \\l1 \\l2 if (nil? l1 || nil? l2) nil $else (zipper (head l1) (head l2)):(zipWith (tail l1) (tail l2))
define zip zipWith (\\x \\y [x y])
zip [1 2 3] [4 5 6]
zip [1 2 3] [4 5]
map
map (\\x x*2) [1 2 3]
reverse
reverse [1 2 3]
length
define length rec\\length \\list if (nil? list) 0 (1 + (length (tail list)))
length
length []
length [1]
length [1 2]
length [1 2 5]
mergeWith
5 + 5
runWorld (lift 1 ;\\_ lift 2)
runWorld (lift 1 ;\\1 lift 2)
runWorld (lift 1 ;\\q lift 2)
runWorld (lift 1 ;\\q lift (2 + q))
div
filter
define filter \\f rec \\filter \\list if (nil? list) nil $else if (f (head l)) (head l):(filter (tail l)) (filter (tail l))
define filter \\f rec \\filter \\list if (nil? list) nil $else if (f (head list)) (head list):(filter (tail list)) (filter (tail list))
filter (\\x x < 5) [1 2 3 4 5 6 7 8]
filter (\\x x < 5 || x > 6) [1 2 3 4 5 6 7 8]
foldl
foldr
range
take
drop
range1
rangeLL
zip
zipWith
map
reverse
length
repeat
mergeWith
merge
mergeSort
mergeSortWith
range 1 10 1
range 1 10 2
range 1 10 3
range 1 10 4
range 1 10 100
range 1 10 100
range 1 10 100
range 1 10
δ 0
#info flip
zip
filter
foldl
foldr
range
take
drop
range1
rangeLL
zip
zipWith
map
reverse
length
repeat
mergeWith
merge
mergeSortWith
++
if (2>=3) 't 'f
define toBool \\v if (v) 't 'f
2>=3 |toBool 
let
let
5 + 25
(5 + 25)]2
(5 + 25)⋅2
f
g
\\f f
f
g
nil? a
nil? 'a
\\f \\g f+g
\\f \\g f'+g
\\f \\g 'f+g
\\f \\g '(f+g)
\\f \\g (f+g)
(\\f \\g (f+g)) 'f 'g
(\\f \\g (f + g)) 'f 'g
1/0
Y
#info Y
#info rec
5 + 2
5 + 2
5 + 2
5 + 2 + 1111
5 + 2 + 1111 + 5555
++
[] ++ []
[] ++ [1]
[] ++ [12]
#info (++)
[12] ++ [12]
foldr
foldr (+) [12] []
#info (++)
[] ++ [12]
nil ++ [12]
[]
nil? []
[] ++ [12]
[]
[] ++ [1]
[] ++ [1]
[] ++ [1]
[] ++ [1]
nil ++ [1]
nil ++ []
nil ++ nil
[1] ++ nil
[] ++ []
nil
[1] ++ []
[] ++ [2]
nil ++ [2]
[] ++ [2]
[]
[]
nil
nil ++ nil
[1] ++ nil
[1] ++ []
[] ++ [1]
nil ++ [1]
1 + 5
1 + 1000
[] ++ nil
[] ++ [1]
[] ++ ni
ni
[] ++ a
[] ++ e
[] ++ e
[ ] ++ e
1+2
[]
[] + []
[] ++ []
[1] ++ [2]
[ ] ++ [2]
nil ++ [2]
[] ++ [1]
5 + 5
5 + 5⋅2
mergeWi
define mergeWith \\lessEqualComparator rec\\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (lessEqualComparator (head l1) (head l2))) (head l1):(mergeWith (tail l1) l2) $else (head l2):(mergeWith l1 (tail l2))
mergeWith (<=) [1 2 3] [4 5 6]
mergeWith (<=) [1 2 5] [3 4]
mergeWith (<=) [1 2 5] [3 4 6]
define mergeWith \\lessEqualComparator rec\\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeWith (tail l1) l2) $else if (lessEqualComparator (head l1) (head l2)) (head l1):(mergeWith (tail l1) l2) $else (head l2):(mergeWith l1 (tail l2))
mergeWith (<=) [1 2 5] [3 4 6]
#t && #t | toBool 
#t && #f | toBool 
#f && #f | toBool 
#f && #t | toBool 
mergeWith (<=) [1 2 5] [3 4 6]
mergeWith (<=) [1 2 5] [3 4 4]
mergeWith (<=) [1 2 5] [3 4 6]
define mergeWith \\lessEqualComparator rec \\mergeWith \\l1 \\l2 if ((nil? l1) && (nil? l2)) nil (if (nil? l2) ((head l1):(mergeWith (tail l1) l2)) (if (lessEqualComparator (head l1) (head l2)) ((head l1):(mergeWith (tail l1) l2)) ((head l2):(mergeWith l1 (tail l2)))))
mergeWith (<=) [1 2 5] [3 4 4]
mergeWith (<=) [1 2 5] [3 4 6]
mergeWith (<=) [1 2 5] [3 4 6]
define mergeWith \\lessEqualComparator rec\\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeWith (tail l1) l2) $else if (lessEqualComparator (head l1) (head l2)) (head l1):(mergeWith (tail l1) l2) $else (head l2):(mergeWith l1 (tail l2))
mergeWith (<=) [1 2 5] [3 4 6]
mergeWith (<=) [1 2] [3 4 6]
mergeWith (<=) [1] [3 4 6]
mergeWith (<=) [1 2 2 2 2 3] [3 4 6]
mergeWith (<=) [1 2] [3 4 6]
mergeWith (<=) [] [3 4 6]
mergeWith (<=) nil [3 4 6]
mergeWith (<=) [] [3 4 6]
mergeWith (<=) [1] [3 4 6]
define mergeWith \\lessEqualComparator rec\\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeWith (tail l1) l2) $else if (nil? l1 || lessEqualComparator (head l1) (head l2)) (head l1):(mergeWith (tail l1) l2) $else (head l2):(mergeWith l1 (tail l2))
define mergeWith \\lessEqualComparator rec\\mergeWith \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeWith (tail l1) l2) $else if (not (nil? l1) && lessEqualComparator (head l1) (head l2)) (head l1):(mergeWith (tail l1) l2) $else (head l2):(mergeWith l1 (tail l2))
mergeWith (<=) [1] [3 4 6]
mergeWith (<=) [1 2] [3 4 6]
div 5 2
def mergeSortWith \\lessEqualComparator rec\\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else merge (take (div (length list) 2) list) (drop (div (length list) 2) list)
def mergeSortWith \\lessEqualComparator rec\\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (take (div (length list) 2) list) (drop (div (length list) 2) list)
mergeSortWith (<=) [1 5 4 3 2 7]
def mergeSortWith \\lessEqualComparator rec\\mergeSortWith \\list if (nil? list || nil? (tail list)) list $else mergeWith lessEqualComparator (mergeSortWith (take (div (length list) 2) list)) (mergeSortWith (drop (div (length list) 2) list))
mergeSortWith (<=) [1 5 4 3 2 7]
") environment) ((\if ((\id ((\else ((\otherwise ((\$ ((\&& ((\|| ((\not ((\< ((\flip ((\> ((\Y ((\rec ((\foldr ((\foldl ((\compose ((\map ((\++ ((\= ((\δ ((\reverse ((\foldl ((\reverse ((\| ((\/= ((\>= ((\≤ ((\≥ ((\div ((\mod ((\% ((\monadWorld ((\monadValue ((\monadLift ((\lift ((\runWorld ((\; ((\implies? ((\equivalent? ((\take ((\drop ((\rangeLL ((\rangeLL ((\range ((\range1 ((\zipWith ((\zip ((\length ((\filter ((\toBool ((\mergeWith ((\mergeWith ((\mergeWith ((\mergeWith ((\mergeWith ((\mergeWith ((\mergeSortWith ((\mergeSortWith nil) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) (mergeSortWith ((take ((div (length list)) 2)) list))) (mergeSortWith ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator (rec (\mergeSortWith (\list (($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeWith) lessEqualComparator) ((take ((div (length list)) 2)) list)) ((drop ((div (length list)) 2)) list))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (($ (((else if) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (else ((: (head l2)) ((mergeWith l1) (tail l2)))))))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (($ (((else if) ((|| (nil? l1)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (else ((: (head l2)) ((mergeWith l1) (tail l2)))))))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (else ((: (head l2)) ((mergeWith l1) (tail l2)))))))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (((if ((&& (nil? l1)) (nil? l2))) nil) (((if (nil? l2)) ((: (head l1)) ((mergeWith (tail l1)) l2))) (((if ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeWith (tail l1)) l2))) ((: (head l2)) ((mergeWith l1) (tail l2))))))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (else ((: (head l2)) ((mergeWith l1) (tail l2)))))))))))))) (\lessEqualComparator (rec (\mergeWith (\l1 (\l2 (($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) ((|| (nil? l2)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeWith (tail l1)) l2)))) (else ((: (head l2)) ((mergeWith l1) (tail l2))))))))))))) (\v (((if v) (' t)) (' f))))) (\f (rec (\filter (\list (($ ((if (nil? list)) nil)) ((((else if) (f (head list))) ((: (head list)) (filter (tail list)))) (filter (tail list)))))))))) (rec (\length (\list (((if (nil? list)) 0) ((+ 1) (length (tail list))))))))) (zipWith (\x (\y ((: x) ((: y) nil))))))) (\zipper (rec (\zipWith (\l1 (\l2 (($ ((if ((|| (nil? l1)) (nil? l2))) nil)) (else ((: ((zipper (head l1)) (head l2))) ((zipWith (tail l1)) (tail l2)))))))))))) (\beginning (\end (((rangeLL 1) end) beginning))))) (\beginning (\end (\step (((rangeLL step) end) beginning)))))) (\step (\end (rec (\rangeLL (\beginning (((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (\step (\end (rec (\rangeLL (\beginning (((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (rec (\drop (\count (\list (((if ((|| ((<= count) 0)) (nil? list))) list) ((drop ((- count) 1)) (tail list))))))))) (rec (\take (\count (\list (((if ((|| ((<= count) 0)) (nil? list))) nil) ((: (head list)) ((take ((- count) 1)) (tail list)))))))))) (\a (\b ((|| ((&& a) b)) ((&& (not a)) (not b))))))) (\a (\b ((|| (not a)) b))))) (\m (\ber (\world ((\r ((ber (monadValue r)) (monadWorld r))) (m world))))))) (\m (monadValue (unsafeRunWorld2 m))))) monadLift)) (\v (\world ((: v) ((: world) nil)))))) (\m (head m)))) (\m (head (tail m))))) mod)) (\a (\b (head (tail ((divmod a) b))))))) (\a (\b (head ((divmod a) b)))))) >=)) <=)) (\a (\b ((<= b) a))))) (\a (\b (not ((= a) b)))))) (\a (\b (b a))))) (\list (((foldl (flip :)) nil) list)))) (\f (rec (\foldl (\v (\list (($ ((if (nil? list)) v)) (((else foldl) ((f v) (head list))) (tail list)))))))))) (\list (((foldl (flip :)) nil) list)))) (\x (((if ((= x) 0)) 1) 0)))) (\a (\b ((&& ((<= a) b)) ((<= b) a)))))) (\a (\b (((foldr :) b) a))))) (\f (\list (((foldr ((compose :) f)) nil) list))))) (\f (\g (\x (f (g x))))))) (\f (rec (\foldl (\v (\list (($ ((if (nil? list)) v)) (((else foldl) ((f (head list)) v)) (tail list)))))))))) (\f (\v (rec (\foldr (\list (($ ((if (nil? list)) v)) (((else f) (head list)) (foldr (tail list))))))))))) Y)) (\f ((\x (f (x x))) (\x (f (x x))))))) (flip <))) (\f (\a (\b ((f b) a)))))) (\a (\b ((&& ((<= a) b)) (not ((<= b) a))))))) (\a (\t (\f ((a f) t)))))) (\a (\b (\t (\f ((a t) ((b t) f)))))))) (\a (\b (\t (\f ((a ((b t) f)) f))))))) (\a (\b (a b))))) id)) id)) (\f f))) (\f f))) nil)