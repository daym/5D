let List := requireModule "List" in 
let Error := requireModule "Error" in
let Composition := requireModule "Composition" in
let Logic := requireModule "Logic" in 
let Arithmetic := requireModule "Arithmetic" in 
import [if else elif] from Logic in 
import [divmod0 (/=) (+) (-) (<)] from Arithmetic in 
import [($) rec (|)] from Composition in 
import [head tail nil? foldr map drop (++) reverse] from List in 
import [listFromStr str? strFromKeyword strFromList substr] from Builtins in 
let strcat := \a \b strFromList ((listFromStr a) ++ (listFromStr b)) in 
let strjoinp := (\sepl \strings 
	let prefixSepl := (\x sepl ++ listFromStr x) in 
	let parts := (map prefixSepl strings) in 
	foldr (++) "" parts
) in 
let strjoin := (\sep \strings 
	let sepl := (listFromStr sep) in 
	if (nil? strings)
		""
	$else
		strFromList (drop (List.length sepl) (strjoinp sepl strings))
) in 
let strFromIntegerBase := 
	let build := \base rec\build\a
		let cr := divmod0 a base in 
		let c := head cr in 
		let r := head (tail cr) in 
		(#\0 + r):(if (c /= 0) (build c) $else [])
	in 
	\base \value
	if (value < 0)
		#\-:(build base (-value) | reverse) | strFromList
	$else
		build base value | reverse | strFromList
in 
let strFromInteger := strFromIntegerBase 10 in 
(requireModule "Composition").dispatch1 (#exports[listFromStr str? strFromKeyword strFromList substr strcat strjoin strFromInteger])
