let Arithmetic := requireModule "Arithmetic" in 
let Logic := requireModule "Logic" in 
let List := requireModule "List" in 
let Composition := requireModule "Composition" in 
import [rec ($) flip] from Composition in 
import [head tail drop foldr zipBy list? map transpose (:)] from List in 
import [not (&&) (||) if else] from Logic in 
import [(-) (*) (+)] from Arithmetic in 
let sum := (\list foldr (+) 0 list) in 
let oldInproduct := (\a \b sum (zipBy (*) a b)) in 
let cartesianProduct := (\f \as \bs map (\a map (\b (f a b)) bs) as) in 
let mmul := (\as \bs cartesianProduct oldInproduct as (transpose bs)) in 
let madd := (rec\madd \as \bs 
	if (list? as && list? bs) 
		zipBy (\a \b madd a b) as bs
	$else 
		(as + bs)
) in 
let cross := (
	let (_) := \l \i head (drop i l) in 
	\a \b
		[(a_1⋅b_2 - a_2⋅b_1) (a_2⋅b_0 - a_0⋅b_2) (a_0⋅b_1 - a_1⋅b_0)]
) in 
let (⨯) := cross in 
(requireModule "Composition").dispatch1 (#exports[mmul madd (⨯) cross])
