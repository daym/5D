let Arithmetic := requireModule "Arithmetic" in 
let Logic := requireModule "Logic" in 
let List := requireModule "List" in 
let Composition := requireModule "Composition" in 
let dispatch := Composition.dispatch in 
let raiseMissingSymbolError := Composition.raiseMissingSymbolError in 
let rec := Composition.rec in 
let ($) := Composition.($) in 
let head := List.head in 
let tail := List.tail in 
let drop := List.drop in 
let foldr := List.foldr in 
let zipBy := List.zipBy in 
let list? := List.list? in 
let map := List.map in 
let transpose := List.transpose in 
let (:) := List.(:) in 
let flip := Composition.flip in 
let not := Logic.not in 
let (&&) := Logic.(&&) in 
let (||) := Logic.(||) in 
let if := Logic.if in 
let else := Logic.else in 
let (-) := Arithmetic.(-) in 
let (*) := Arithmetic.(*) in 
let (+) := Arithmetic.(+) in 
let sum := (\list foldr (+) 0 list) in 
let oldInproduct := (\a \b sum (zipBy (*) a b)) in 
let cartesianProduct := (\f \as \bs map (\a map (\b (f a b)) bs) as) in 
let mmul := (\as \bs cartesianProduct oldInproduct as (transpose bs)) in 
let madd := (rec\madd \as \bs 
	if (list? as && list? bs) 
		zipBy (\a \b madd a b) as bs
	$else 
		(as + bs)
) in 
let cross := 
	let (_) := \l \i head (drop i l) in 
	\a \b
		[(a_1⋅b_2 - a_2⋅b_1) (a_2⋅b_0 - a_0⋅b_2) (a_0⋅b_1 - a_1⋅b_0)]
) in 
let (⨯) := cross in 
(requireModule "Composition").dispatch (#exports[mmul madd (⨯) cross])
raiseMissingSymbolError
