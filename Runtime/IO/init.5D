let List := requireModule "List" in 
let Error := requireModule "Error" in 
let Composition := requireModule "Composition" in
let Logic := requireModule "Logic" in 
import [dispatch raiseMissingSymbolError rec (|) ($)] from Composition in 
import [head tail] from List in 
import [if else] from Logic in 
import [flush! stderr stdin stdout readline! write! errno!] from Builtins in 
let ioValue := (\m head m) in 
let ioWorld := (\m head (tail m)) in 
let (;) := (\m \ber \world (\r ber (ioValue r) (ioWorld r)) (m world)) in
let liftIO! := (\v \world [v world]) in 
let return! := liftIO! in 
let skipUntil! := (\condition \body rec\skipUntil! 
	\world
		let result := body world in 
		if (condition (ioValue result))
			result
		$else
			skipUntil! (ioWorld result)
) in 
let skipWhile! := (\condition \body rec\skipWhile! 
	\world
		let result := body world in 
		if (condition (ioValue result))
			skipWhile! (ioWorld result)
		$else
			result
) in 
let accumrUntil! := (\condition \connector \terminator \body rec\accum!
	\world
		let result := body world in 
		let value := ioValue result in 
		if (condition value)
			liftIO! terminator (ioWorld result)
		$else
			let t := (accum! (ioWorld result)) in 
			let value2 := ioValue t in 
			liftIO! (connector value value2) (ioWorld t)
) in 
(requireModule "Composition").dispatch1 (#exports[ioValue ioWorld liftIO! return! flush! stderr stdin stdout readline! (;) write! errno! skipUntil! skipWhile! accumrUntil!])
