let List := requireModule "List" in 
let Error := requireModule "Error" in 
let Composition := requireModule "Composition" in
let Logic := requireModule "Logic" in 
let dispatch := Composition.dispatch in
let raiseMissingSymbolError := Composition.raiseMissingSymbolError in
let head := List.head in 
let tail := List.tail in 
let rec := Composition.rec in 
let ioValue := (\m head m) in 
let ioWorld := (\m head (tail m)) in 
let (;) := (\m \ber \world (\r ber (ioValue r) (ioWorld r)) (m world)) in
let ($) := Composition.($) in 
let if := Logic.if in 
let else := Logic.else in 
let liftIO! := (\v \world [v world]) in 
let return! := liftIO! in 
let flush! := Builtins.flush! in 
let stderr := Builtins.stderr in 
let stdin := Builtins.stdin in 
let stdout := Builtins.stdout in 
let readline! := Builtins.readline! in 
let write! := Builtins.write! in 
let errno! := Builtins.errno! in 
let until! := (\condition \body rec\until! 
	\world
		let result := body world in 
		if (condition (ioValue result))
			result
		$else
			until! (ioWorld result)
) in 
let while! := (\condition \body rec\r 
	\world
		let result := body world in 
		if (condition (ioValue result))
			r (ioWorld result)
		$else
			result
) in 
let accumrUntil! := (\condition \connector \terminator \body rec\accum!
	\world
		let result := body world in 
		let value := ioValue result in 
		if (condition value)
			[terminator (ioWorld result)]
		$else
			let t := (accum! (ioWorld result)) in 
			let value2 := ioValue t in 
			[(connector value value2) (ioWorld t)]
) in 
(requireModule "Composition").#exports [ioValue ioWorld liftIO! return! flush! stderr stdin stdout readline! (;) write! errno! until! while! accumrUntil!]
raiseMissingSymbolError
