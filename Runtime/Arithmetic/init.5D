let Logic := requireModule "Logic" in 
let Composition := requireModule "Composition" in 
let Error := requireModule "Error" in 
import [head tail (:) nan? infinite? nan infinity] from Builtins in 
import [dispatch raiseMissingSymbolError rem rec flip ($) compose] from Composition in 
import [not (&&) (||) if else elif] from Logic in 
import [(-) (*) (/) (+) (<=) divmod0] from Builtins in 
let infinity? := infinite? in 
let inf? := infinite? in 
let inf := infinity in 
let (∞?) := inf? in 
let (∞) := inf in 
let (≤) := (<=) in 
let (<) := (\a \b a <= b && not (b <= a)) in 
let (=) := (\a \b a <= b && b <= a) in 
let (>=) := flip (<=) in 
let (≥) := (>=) in 
let (>) := flip (<) in 
let (/=) := \a \b not (a = b) in 
let abs := (\x if (x <= 0) (0 - x) x) in 
let div0 := (\a \b head (divmod0 a b)) in 
let mod0 := (\a \b head (tail (divmod0 a b))) in 
rem'(modulo := (\a \b mod0 (b + mod0 a b) b) in)
let divmod := \a \b
	if (0 <= a)
		divmod0 a b
	$else
		let cr := (divmod0 a b) in 
		let c := head cr in 
		let r := head (tail cr) in 
		rem "sign of r is either negative or r is equal to zero. Note that resulting modulus must always be positive or zero."
		if (r < 0)
			if (b < 0)
				[(c + 1) (r - b)]
			$else
				[(c - 1) (r + b)]
		$else
			[c r]
in
let zero? := (\a (a = 0)) in 
let positive? := (\a a > 0) in 
let negative? := (\a a < 0) in 
let even? := (\a mod0 a 2 = 0) in 
let odd? := (\a not (even? a)) in 
let finite? := \a 
	not (infinite? a) && not (nan? a)
in 
let div := (\a \b head (divmod a b)) in 
let mod := (\a \b head (tail (divmod a b))) in 
let (%) := mod in 
let pi := 3.141592653589793 in 
let π := pi in 
let cos := \angle
	let approx := (\x 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720) in 
	approx ((mod (angle + pi) 2⋅pi) - pi)
in
let sin := \angle
	let approx := (\x x - x*x*x/6 + x*x*x*x*x/120 - x*x*x*x*x*x*x/(120*6*7)) in 
	approx ((mod (angle + pi) 2⋅pi) - pi)
in
let tan := (\x (sin x)/(cos x)) in 
let next := (\N \x (x + N/x)/2) in 
let relativeWithin := \eps rec\within \list
	rem "doesn't work for √0"
	let a := head list in 
	let b := head (tail list) in 
	if (abs (a - b) <= eps*(abs b)) 
		b 
	$else
		within b:(tail (tail list))
in 
let within := \eps rec\within \list
	let a := head list in 
	let b := head (tail list) in 
	if (abs (a - b) <= eps) 
		b 
	$else
		within b:(tail (tail list))
in 
let repeat := (\f rec (\repeat \a a:(repeat (f a)))) in 
let sqrtEps := \a0 \eps \N 
	if (N < eps)
		0
	$elif (N < 10)
		relativeWithin eps (repeat (next N) a0) 
	$else
		within eps (repeat (next N) a0) 
in 
let sqrt := sqrtEps 1 0.001 in 
let √ := sqrt in 
let ground := (\v div0 v 1) in 
let floor := (\v div v 1) in 
let ceiling := \v
	if ((ground v) = v)
		v
	$else
		(floor v) + 1
in 
let factorial := (\v
	if ((ground v) = v)
		(rec\fac \v
			if (v = 0)
				1
			$else
				v*(fac (v - 1))
		) v
	$else
		Error.raiseErrorWithCode "factorial only works for natural numbers - maybe you meant gamma" 500
) in 
let round1 := (\v 
	if (0 <= v) 
		ground (v + 1/2)
	$else
		ground (v - 1/2)
) in 
let max := (\a \b if (a <= b) b a) in 
let min := (\a \b if (a <= b) a b) in 
let gcd := (rec\gcd \a \b
	if (b = 0) 
		a
	$else
		gcd b (a % b)
) in 
let (**) := \a rec\r\b
	rem "FIXME non-natural b"
	if (b = 0)
		1
	$else
		a*(r (b - 1))
in 
let log2 := rec\log2 \a
	rem "FIXME"
	if(a <= 1)
		0
	$else
		1 + (log2 (a/2))
in 
let round1Log2 := compose round1 log2 in 
(requireModule "Composition").dispatch1 (#exports[(-) (*) (/) (%) (+) (<) (<=) (≤) (=) (≥) (>) (>=) (/=) √ abs div0 divmod0 mod0 div divmod mod cos sin tan sqrt within factorial ground floor round1 π pi max min gcd ceiling zero? positive? negative? even? odd? nan? finite? infinite? nan infinity infinity? inf inf? log2 round1Log2 (**) ∞ ∞?])
