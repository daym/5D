(((((REPLV1 textBufferText) "5 + 2
5 + 5
5 + 5⋅3
f
f x + g x
\\f \\g \\x (f x + g x)
\\f \\g \\x (f x + g x) 'f 'g 'x
(\\f \\g \\x (f x + g x)) 'f 'g 'x
int0 
intSucc int0 
integerSucc int0 
(
(
)
div 5 0
divmod 5 0
5 + 5
5 + 5⋅100
define if \\f f
define id \\f f
define else id
define otherwise id
define ($) \\a \\b a b
if (2 < 3) 't 'f
define (<) \\a \\b (a <= b) && not (b <= a)
define (&&) \\a \\b \\t \\f a (b t f) f
define (||) \\a \\b \\t \\f a t (b t f)
define not \\a \\t \\f a f t
define (<) \\a \\b (a <= b) && not (b <= a)
define flip \\f \\a \\b f b a
define (>) flip (<)
1<2
if (1 < 2) 't 'f
define foldr \\f \\v rec \\foldr \\list if (nil? list) v $else f (head list) (foldr (tail list))
define Y \\f (\\x f (x x)) (\\x f (x x))
define rec Y
define foldr \\f \\v rec \\foldr \\list if (nil? list) v $else f (head list) (foldr (tail list))
if (1 < 2) 't 'f
foldr (+) 0 [1 2 3]
define foldl \\f rec\\foldl \\v \\list if (nil? list) v $else foldl (f (head list) v) (tail list) 
foldl (+) 0 [1 2 3]
define compose \\f \\g \\x f (g x)
define map \\f \\list (foldr (compose (:) f) [] list)
map (\\x x*2) [1 2 3]
define (++) \\a \\b foldr (:) b a
[1 2 3] ++ [4 5 6]
1=2
define (=) \\a \\b (a <= b) && (b <= a)
1=1
if (1=1) 't 'f
δ
define δ \\x if (x = 0) 1 0
δ 0
δ 1
δ (2-2)
filter
define reverse \\list (foldl (flip (:)) [] list)
reverse (listFromStr \"hello\")
define foldl \\f rec\\foldl \\v \\list if (nil? list) v $else foldl (f v (head list)) (tail list) 
define reverse \\list (foldl (flip (:)) [] list)
reverse (listFromStr \"hello\")
strFromList (reverse (listFromStr \"hello\"))
reverse (listFromStr \"hello\") |strFromList
define (|) \\a \\b b a
reverse (listFromStr \"hello\") |strFromList
id
if
else
flip
rec
otherwise
compose
toBool
|
&&
||
not
implies?
equivalent?
<
=
>
define (/=) \\a \\b not (a = b)
>=
define (>=) \\a \\b (b <= a)
if (5 >= 2) 't 'f
define (≤) <=
define (≥) (>=)
define div \\a \\b head (divmod a b)
define mod \\a \\b head (tail (divmod a b))
mod 5 2
define (%) mod
define ioWorld \\m head (tail m)
define ioValue \\m head m
define liftIO \\v \\world [v world]
define lift liftIO
define runIO \\m ioValue (unsafeRunWorld2 m)
runIO (lift 2)
runIO (lift 42)
filter
foldl
foldr
range
take
drop
define (;) \\m \\ber \\world let r = (m world) in ber (ioValue r) (ioWorld r)
runIO (lift 42 ;\\v lift 2)
runIO (lift 42 ;\\v lift (2 + v))
define implies? \\a \\b (not a || b)
if (implies? #t #f) 't 'f
if (implies? #f #f) 't 'f
if (implies? #f #t) 't 'f
if (implies? #t #t) 't 'f
define equivalent? \\a \\b (a && b) || ((not a) && (not b))
equivalent? 
define take rec\\take \\count \\list if (count <= 0 || nil? list) nil (head list):(take (count - 1) (tail list))
take 2 [3 4 5]
take 5 [3 4 5]
take (-1) [3 4 5]
define drop rec\\drop \\count \\list if (count <= 0 || nil? list) list (drop (count - 1) (tail list))
drop 2 [3 4 5]
drop 200 [3 4 5]
drop 3 [3 4 5]
drop 1 [3 4 5]
drop 0 [3 4 5]
drop (-1) [3 4 5]
[3 4 5] ++ [6]
filter
foldl
foldr
range
define rangeLL \\step \\end rec\\rangeLL \\beginning if (step <= (-1)) (if (beginning <= end) nil beginning:(rangeLL (beginning + step))) (if (beginning >= end) nil beginning:(rangeLL (beginning + step)))
rangeLL 1 0 10
define rangeLL \\step \\end rec\\rangeLL \\beginning if (step <= (-1)) (if (beginning <= end) nil (beginning:(rangeLL (beginning + step)))) (if (beginning >= end) nil (beginning:(rangeLL (beginning + step))))
rangeLL 1 0 10
rangeLL 1 10 0
rangeLL 1 10 0
define range \\beginning \\end \\step (rangeLL step end beginning)
range 0 10 1
range 0 10 (-1)
range 9 (-1) (-1)
define range1 \\beginning \\end rangeLL 1 end beginning
range1 1 10
zipBy
define zipBy \\zipper rec\\zipBy \\l1 \\l2 if (nil? l1 || nil? l2) nil $else (zipper (head l1) (head l2)):(zipBy (tail l1) (tail l2))
define zip zipBy (\\x \\y [x y])
zip [1 2 3] [4 5 6]
zip [1 2 3] [4 5]
map
map (\\x x*2) [1 2 3]
reverse
reverse [1 2 3]
length
define length rec\\length \\list if (nil? list) 0 (1 + (length (tail list)))
length
length []
length [1]
length [1 2]
length [1 2 5]
mergeBy
5 + 5
runIO (lift 1 ;\\_ lift 2)
runIO (lift 1 ;\\1 lift 2)
runIO (lift 1 ;\\q lift 2)
runIO (lift 1 ;\\q lift (2 + q))
div
filter
define filter \\f rec \\filter \\list if (nil? list) nil $else if (f (head l)) (head l):(filter (tail l)) (filter (tail l))
define filter \\f rec \\filter \\list if (nil? list) nil $else if (f (head list)) (head list):(filter (tail list)) (filter (tail list))
filter (\\x x < 5) [1 2 3 4 5 6 7 8]
filter (\\x x < 5 || x > 6) [1 2 3 4 5 6 7 8]
foldl
foldr
range
take
drop
range1
rangeLL
zip
zipBy
map
reverse
length
repeat
mergeBy
merge
mergeSort
mergeSortBy
range 1 10 1
range 1 10 2
range 1 10 3
range 1 10 4
range 1 10 100
range 1 10 100
range 1 10 100
range 1 10
δ 0
#info flip
zip
filter
foldl
foldr
range
take
drop
range1
rangeLL
zip
zipBy
map
reverse
length
repeat
mergeBy
merge
mergeSortBy
++
if (2>=3) 't 'f
define toBool \\v if (v) 't 'f
2>=3 |toBool 
let
let
5 + 25
(5 + 25)]2
(5 + 25)⋅2
f
g
\\f f
f
g
nil? a
nil? 'a
\\f \\g f+g
\\f \\g f'+g
\\f \\g 'f+g
\\f \\g '(f+g)
\\f \\g (f+g)
(\\f \\g (f+g)) 'f 'g
(\\f \\g (f + g)) 'f 'g
1/0
Y
#info Y
#info rec
5 + 2
5 + 2
5 + 2
5 + 2 + 1111
5 + 2 + 1111 + 5555
++
[] ++ []
[] ++ [1]
[] ++ [12]
#info (++)
[12] ++ [12]
foldr
foldr (+) [12] []
#info (++)
[] ++ [12]
nil ++ [12]
[]
nil? []
[] ++ [12]
[]
[] ++ [1]
[] ++ [1]
[] ++ [1]
[] ++ [1]
nil ++ [1]
nil ++ []
nil ++ nil
[1] ++ nil
[] ++ []
nil
[1] ++ []
[] ++ [2]
nil ++ [2]
[] ++ [2]
[]
[]
nil
nil ++ nil
[1] ++ nil
[1] ++ []
[] ++ [1]
nil ++ [1]
1 + 5
1 + 1000
[] ++ nil
[] ++ [1]
[] ++ ni
ni
[] ++ a
[] ++ e
[] ++ e
[ ] ++ e
1+2
[]
[] + []
[] ++ []
[1] ++ [2]
[ ] ++ [2]
nil ++ [2]
[] ++ [1]
5 + 5
5 + 5⋅2
mergeWi
define mergeBy \\lessEqualComparator rec\\mergeBy \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2 || (lessEqualComparator (head l1) (head l2))) (head l1):(mergeBy (tail l1) l2) $else (head l2):(mergeBy l1 (tail l2))
mergeBy (<=) [1 2 3] [4 5 6]
mergeBy (<=) [1 2 5] [3 4]
mergeBy (<=) [1 2 5] [3 4 6]
define mergeBy \\lessEqualComparator rec\\mergeBy \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeBy (tail l1) l2) $else if (lessEqualComparator (head l1) (head l2)) (head l1):(mergeBy (tail l1) l2) $else (head l2):(mergeBy l1 (tail l2))
mergeBy (<=) [1 2 5] [3 4 6]
#t && #t | toBool 
#t && #f | toBool 
#f && #f | toBool 
#f && #t | toBool 
mergeBy (<=) [1 2 5] [3 4 6]
mergeBy (<=) [1 2 5] [3 4 4]
mergeBy (<=) [1 2 5] [3 4 6]
define mergeBy \\lessEqualComparator rec \\mergeBy \\l1 \\l2 if ((nil? l1) && (nil? l2)) nil (if (nil? l2) ((head l1):(mergeBy (tail l1) l2)) (if (lessEqualComparator (head l1) (head l2)) ((head l1):(mergeBy (tail l1) l2)) ((head l2):(mergeBy l1 (tail l2)))))
mergeBy (<=) [1 2 5] [3 4 4]
mergeBy (<=) [1 2 5] [3 4 6]
mergeBy (<=) [1 2 5] [3 4 6]
define mergeBy \\lessEqualComparator rec\\mergeBy \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeBy (tail l1) l2) $else if (lessEqualComparator (head l1) (head l2)) (head l1):(mergeBy (tail l1) l2) $else (head l2):(mergeBy l1 (tail l2))
mergeBy (<=) [1 2 5] [3 4 6]
mergeBy (<=) [1 2] [3 4 6]
mergeBy (<=) [1] [3 4 6]
mergeBy (<=) [1 2 2 2 2 3] [3 4 6]
mergeBy (<=) [1 2] [3 4 6]
mergeBy (<=) [] [3 4 6]
mergeBy (<=) nil [3 4 6]
mergeBy (<=) [] [3 4 6]
mergeBy (<=) [1] [3 4 6]
define mergeBy \\lessEqualComparator rec\\mergeBy \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeBy (tail l1) l2) $else if (nil? l1 || lessEqualComparator (head l1) (head l2)) (head l1):(mergeBy (tail l1) l2) $else (head l2):(mergeBy l1 (tail l2))
define mergeBy \\lessEqualComparator rec\\mergeBy \\l1 \\l2 if (nil? l1 && nil? l2) nil $else if (nil? l2) (head l1):(mergeBy (tail l1) l2) $else if (not (nil? l1) && lessEqualComparator (head l1) (head l2)) (head l1):(mergeBy (tail l1) l2) $else (head l2):(mergeBy l1 (tail l2))
mergeBy (<=) [1] [3 4 6]
mergeBy (<=) [1 2] [3 4 6]
div 5 2
def mergeSortBy \\lessEqualComparator rec\\mergeSortBy \\list if (nil? list || nil? (tail list)) list $else merge (take (div (length list) 2) list) (drop (div (length list) 2) list)
def mergeSortBy \\lessEqualComparator rec\\mergeSortBy \\list if (nil? list || nil? (tail list)) list $else mergeBy lessEqualComparator (take (div (length list) 2) list) (drop (div (length list) 2) list)
mergeSortBy (<=) [1 5 4 3 2 7]
def mergeSortBy \\lessEqualComparator rec\\mergeSortBy \\list if (nil? list || nil? (tail list)) list $else mergeBy lessEqualComparator (mergeSortBy (take (div (length list) 2) list)) (mergeSortBy (drop (div (length list) 2) list))
mergeSortBy (<=) [1 5 4 3 2 7]
mergeSort [5 4 3 2 1]
mergeSortBy (<=) [5 4 3 2 1]
define mergeSort mergeSortBy (<=)
mergeSort [5 4 3 2 1]
fac
define factorial rec\\fac \\v if (v = 0) 1 v⋅(fac (v - 1))
factorial 5
id
if
else
flip
rec
otherwise
compose
toBool 
|
&&
||
not
implies?
equivalent? 
<
=
/=
>
>=
≤
<=
≥
%
*
+
-
(-)
(/)
div
divmod
mod
ioWorld
lift
liftIO
;
ioValue
runIO 
filter
foldl
foldr
range
take
drop
range1
rangeLL
zip
zipBy
map
reverse
length
repeat
mergeBy 
merge
mergeSort
mergeBy
merge
define merge mergeBy (<=)
mergeBy
merge
merge [1 2] [3 4]
zip
define assq \\key rec\\assq \\alist if (nil? alist) nil $ if (symbolsEqual? (head (assq)) key) (head assq) $ assq (tail alist)
assq $ zip ['cos 'sin] [1 2]
(assq $ zip ['cos 'sin] [1 2])
(assq 'cos $ zip ['cos 'sin] [1 2])
define assq \\key rec\\assq \\alist if (nil? alist) nil $else if (symbolsEqual? (head alist) key) (head alist) $else assq (tail alist)
(assq 'cos $ zip ['cos 'sin] [1 2])
define assq \\key rec\\assq \\alist if (nil? alist) nil $else if (symbolsEqual? (head alist) key) (head alist) $else (assq (tail alist))
(assq 'cos $ zip ['cos 'sin] [1 2])
(assq 'cos (zip ['cos 'sin] [1 2]))
define assq \\key rec\\assq \\alist if (nil? alist) nil $else if (symbolsEqual? (head (head alist)) key) (head alist) $else (assq (tail alist))
(assq 'cos (zip ['cos 'sin] [1 2]))
(assq 'cos (zip ['cos 'sin] [1 2])) |tail |head
define dispatchModule \\list \\key assq key list | tail | head
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
dispatchModule (zip ['cos 'sin] [1 2]) 'cos
dispatchModule (zip ['cos 'sin] [1 2]) 'cos
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
dispatchModule (zip ['cos 'sin] [1 2]) 
dispatchModule (zip ['cos 'sin] [1 2]) 
dispatchModule (zip ['cos 'sin] [1 2]) 1
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
describe foo
describe foo
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
dispatchModule (zip ['cos 'sin] [1 2]) 'cos
dispatchModule (zip ['cos 'sin] [1 2]) 'cos
dispatchModule (zip ['cos 'sin] [1 2]) 'sin
dispatchModule (zip ['cos 'sin] [1 2]) 'sins
dispatchModule (zip ['cos 'sin] [1 2]) 'sins
describe foo
describe foo
describe foo
describe foo
describe foo
⟨⟩
⟨⟩
describe foo
describe 'foo
addrsLE? 
addrsLE? 
addrsLE? 
addrsLE? 1 2
describe 'foo
describe 'foo
2
2 + 3
2 + 3
foo
strcat \"a\" \"b\"
\"a\"
\"a\"
\"a\"
runIO 
runIO 
\"a\"
\"a\"
strcat
listFromStr \"a\"
listFromStr \"a\"
\"a\"
\"a\"
\"a\"
\"b\"
\"c\"
packRecord \"i\" [1]
unpackRecord \"i\" \"\\x01\\x00\\x00\\x00\"
recordSize \"i\"
allocateRecord \"i\"
allocateRecord 42
allocateRecord 42
allocateRecord \"i\"
allocateRecord \"i\"
let t = allocateRecord (recordSize \"i\") in POSIX'localtime t
import @fileName:\"POSIX/POSIX.5D\" 'POSIX
let t = allocateRecord (recordSize \"i\") in POSIX'localtime t
run (let t = allocateRecord (recordSize \"i\") in POSIX'localtime t)
runIO (let t = allocateRecord (recordSize \"i\") in POSIX'localtime t)
return
define return liftIO
POSIX'localtimeR
POSIX'localtimeR 2
run (POSIX'localtimeR 2)
runIO (POSIX'localtimeR 2)
(POSIX'localtimeR 2)
(packRecord \"I\" 2:[])
(allocateRecord (recordSize \"iiiiiiiii\"))
POSIX.exports
define (.) (')
POSIX.exports
POSIX'exports
define (.) \\a \\b a b
POSIX.exports
POSIX.exports
runIO (POSIX.link \"a\" \"b\")
runIO (POSIX.link \"a\" \"b\")
runIO (POSIX.link \"Q\" \"b\")
runIO (POSIX.link \"Q\" \"b\")
POSIX'exports
POSIX'exports
POSIX.exports
allocateRecord 
allocateRecord \"i\"
run (allocateRecord \"i\")
runIO (allocateRecord \"i\")
.
.a
a.b
mergeSort [1 2 3]
mergeSort [2 3 2 1]
mergeSort [2 3 2 1 1 5  62 41]
mergeSort (range 0 10 1)
mergeSort (range 0 100 1)
POSIX.time
POSIX.time []
run (POSIX.time [])
run
define run runIO
run
run $ POSIX.time []
run $ POSIX.time []
run $ POSIX.time []
run $ POSIX.time []
run $ POSIX.time []
POSIX.time [] ;\\t POSIX.localtime t
run $ POSIX.time [] ;\\t POSIX.localtime t
run $ (POSIX.time [] ;\\t POSIX.localtime t)
run $ (POSIX.time [] ;\\t POSIX.localtime t)
run $ (POSIX.time [] ;\\t POSIX.localtime t)
run $ (POSIX.time [] ;\\t POSIX.localtime t)
run $ (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
POSIX.exports
POSIX.fopen
POSIX.fopen \"foo\" \"w\"
run (POSIX.fopen \"foo\" \"w\" ;\\f POSIX.fwrite f \"test\" 4 ;\\_ POSIX.fclose f)
POSIX.fwrite
run (POSIX.fopen \"foo\" \"w\" ;\\f POSIX.fwrite \"test\" 4 1 f ;\\_ POSIX.fclose f)
duplicateRecord 
packRecord \"i\" 1
packRecord \"i\" [1]
packRecord \"i\" [2]
packRecord \"i\" [4]
packRecord \"i\" [(-4)]
(-4)
0-1
0-45
-45
2
-2
(0-2)
(0-2.3)
(0-2.4)
(0-2.5)
(0-2.6)
packRecord \"i\" [(0-2)]
unpackRecord (packRecord \"i\" [(0-2)])
unpackRecord \"i\" (packRecord \"i\" [(0-2)])
unpackRecord \"i\" (packRecord \"i\" [(0-4)])
unpackRecord \"i\" (packRecord \"i\" [(0-4)])
-4
-2
\\x x
\\x x
\\x x
(\\x x) 1
-1
-1
(-1)
5-2
5-2
56-3
56-3
5-3
5⋅3
-3
(-3)
(-3)
3
3.2
3.2E-2
3.2E-2
3.2E-2
5-2
5-2
-2
5-2
5-2
1-2
1-2-3-4
5⋅-2
5⋅(-2)
(-2)
(-2)
(2)
(2)
(-2)
(-2)
-3
-3-2
-(3-2)
-10.3
'a 'a
'a 'a
id 1
id 'a
-5
-5.3
-5.3 - 676
-5.3 - 676
-5.3 - 676
listFromStr \"hello\"
strFromList [104 101 108 108 111]
5 + 2
5 + 2
POSIX
POSIX.exports
POSIX.open
POSIX.open \"a\"
run (POSIX.open \"a\" 1 664)
run (POSIX.open \"a\" POSIX.O_CREAT 664)
run (POSIX.open \"a\" POSIX.oCREAT 664)
run (POSIX.close 3)
run (POSIX.close 3)
zip
POSIX.system
POSIX.exec
POSIX.execv
POSIX.execvp
POSIX.execvpe
POSIX.execve
POSIX.spawnv
POSIX.spawnvp
POSIX.spawnvpe
POSIX.fork
run $ POSIX.fork
POSIX.pipe
POSIX.pipe (allocateRecord \"ii\")
run (let r = (allocateRecord \"ii\") in POSIX.pipe r ;\\rc r)
allocateRecord \"ii\"
run (allocateRecord \"ii\" ;\\r POSIX.pipe r ;\\rc r)
run (allocateRecord \"ii\" ;\\r POSIX.pipe r ;\\rc return r)
run (allocateRecord \"ii\" ;\\r POSIX.pipe r ;\\rc return unpackRecord \"ii\" r)
run (allocateRecord \"ii\" ;\\r POSIX.pipe r ;\\rc return (unpackRecord \"ii\" r))
POSIX.pipe
POSIX.pipe
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipex)
run (POSIX.pipe)
run (POSIX.pipe )
run (POSIX.pipe )
run (POSIX.pipex)
run (POSIX.pipex)
run
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
run (POSIX.pipe)
ls
duplicateRecord \"ii\"
run $ duplicateRecord \"ii\"
run $ duplicateRecord \"hello\"
run $ duplicateRecord \"hello\"
run $ duplicateRecord \"hello\"
run $ duplicateRecord \"hellox\"
\"hello\"
\"hello\" = \"hello\"
\"hello\" = \"hello\" | toBool 
\"hello\" = \"hello\" | toBool 
\"hello\" = \"hello\" | toBool 
POSIX.exports
POSIX.oNOCTTY
#x52
#x52
151 + 232
POSIX.open
POSIX.open
POSIX.open
POSIX.open
POSIX.open
POSIX.open
make
5 + 2
5 + 233.3
POSIX.open
requireModule 
requireModule 'OS
requireModule \"POSIX/POSIX.5D\"
require
requireModule 
requireModule \"A\"
open
a
5
[1 2 3]
[1 2 3]
[1 '2]
[1 '2 '3]
[1 'x]
[1 'x 'y]
[5⋅3]
[5⋅3 2]
[5⋅3 2⋅5]
[5⋅3 2⋅5 5 + 2]
[5⋅3 2⋅5 5 + 2]
POSIX.exports
POSIX.exports
POSIX.exports
POSIX
POSIX.mmap
OS
import 'OS
import 'OS
archDepLibName \"a\"
archDepLibName \"a\"
archDepLibName \"aaa\"
import 'OS
import 'OS
OS
OS.exports
OS.open
OS
OS.exports
OS.exports
OS.exports
OS.exports
OS.exports
OS.exports
archDepLibName 
archDepLibName \"a\"
archDepLibName \"a\"
archDepLibName \"a\"
POSIX
import 'POSIX
POSIX
POSIX
POSIX.exports
POSIX.p[en
POSIX.open
POSIX.exports
POSIX.exports
POSIX.open
POSIX.gmtime
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.gmtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
return
OS
OS.exports
import 'OS
OS.exports
OS.exports
POSIX.exports
POSIX.close
POSIX.open
POSIX.close
OS.close
run (OS.close 1)
run (OS.close 0)
run (OS.close 0)
stdin
stdout
write stdout
write stdout \"a'
write stdout \"a\"
write stdout \"a
\"a
\"a\"
>=
=
describe '=
describe ('=)
'a 'a
describe '=
id '=
describe (=)
(=)
describe '=
describe if
describe 'if
describe '=
'=
'
'=
'=
'=
(=)
'(=)
describe '(=)
describe ('(=))
describe ('(=))
describe '(=)
'(=)
'=
'x
''
'a
'a
describe (=)
(=)
(=)
'(=)
'=
'=
'a
'a
'=
'=
'=
'a 
'a 2
'a 'a
'=
'a 'a
'=
describe (=)
(=)
(=)
describe '=
describe '(=)
describe '=
(=)
(=)
=
=
=
=
(=)
(=)
(=)
((((=))))
((((=))))
describe '=
describe '(=)
describe (=)
(=)
describe '=
describe '(=)
describe (=)
POSIX.select
POSIX.poll
POSIX.epoll
POSIX.pselect
POSIX.exports
POSIX.poll
POSIX.fmemopen
POSIX.fmemopen
POSIX.exports
POSIX.brk
POSIX.brk 0
POSIX.brk 0
POSIX.brk 0
POSIX.exports
POSIX.strftime
POSIX.fgets
POSIX.close
POSIX.symlink
POSIX.symlink
POSIX.symlink \"a\" \"b\"
run $ POSIX.symlink \"a\" \"b\"
run $ POSIX.symlink \"a\" \"b\"
POSIX.
POSIX.read
POSIX.open
POSIX.exportrs
POSIX.exports
POSIX.exports
POSIX.exports
POSIX.exports
POSIX.ttyslot
POSIX.exports
POSIX.strftime
remove
POSIX.remove
run $ POSIX.ctermid
run $ POSIX.ctermid []
run $ (POSIX.ctermid [])
run $ (POSIX.ctermid [])
POSIX.exports
POSIX.exports
POSIX.exports
POSIX.clock
POSIX.clock []
POSIX.clock 
run POSIX.clock 
run POSIX.clock 
run POSIX.clock 
run POSIX.clock 
divmod 5 2
POSIX
POSIX.exports
run (POSIX.time [] ;\\t POSIX.localtime t ;\\tm POSIX.strftime \"%Y-%m-%d\" tm)
run (POSIX.time [] ;\\t POSIX.localtime t ;\\tm POSIX.strftime \"%Y-%m-%d\" tm)
run (POSIX.time [] ;\\t POSIX.localtime t ;\\tm POSIX.strftime \"%Y-%m-%d\" tm)
run (POSIX.time [] ;\\t POSIX.localtime t ;\\tm POSIX.strftime \"%Y-%m-%d\" tm)
POSIX
POSIX
POSIX.signal
POSIX.signals
POSIX.signal
δ 5
/=
1/=2
1/=2 |toBool 
[1 2 3] ++ [4 5 6]
OS.chown
POSIX.exports
POSIX.rename
POSIX.ttynameR
POSIX.ttyname 1
POSIX.ttyname 1
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
strlen
strUntilZwero
strUntilZero
ttyname
POSIX.ttyname
strlen
strUntilZero 
strUntilZero \"a\"
strUntilZero \"ab\"
strUntilZero \"abc\"
POSIX.ttyname 1
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
POSIX.exports
POSIX.execve
POSIX.execv
run $ POSIX.execv \"ls\" \"ls\"
run $ POSIX.execvp \"ls\" \"ls\"
run $ POSIX.execvp \"/bin/ls\" \"/bin/ls\"
run $ POSIX.execvp \"/bin/ls\" []
run $ POSIX.execvp \"/bin/ls\" []
POSIX.export
POSIX.export
POSIX.exports
packRecord \"q\" [1]
packRecord \"qq\" [1]
packRecord \"qq\" [1 2]
packRecord \"qq\" [1 2]
packRecord \"qq\" [1 2]
packRecord \"qq\" [1 2]
packRecord \"qq\" [1 2]
packRecord \"qq\" [1 2]
packRecord \"qq\" [1 2 3]
packRecord \"qq\" [1 2 3 -4]
packRecord \"qq\" [1 2 3 (-4)]
packRecord \"qq\" [1 2 (-)]
packRecord \"qq\" [1 2 (-1)]
packRecord \"qq\" [1 2 (-1)]
packRecord \"qq\" [1 2 (-1)]
packRecord \"qq\" [1 (-1)]
packRecord \"qq\" [1 (-1)]
packRecord \"qq\" [1 (-1)]
packRecord \"qq\" [1 (-1)]
packRecord \"bb\" [255 (-1)]
packRecord \"bb\" [127 (-1)]
packRecord \"bq\" [127 (-1)]
packRecord \"bq\" [127 (-1)]
packRecord \"bq\" [128 (-1)]
packRecord \"bq\" [129 (-1)]
packRecord \"bq\" [256 (-1)]
packRecord \"bq\" [255 (-1)]
packRecord \"Bq\" [255 (-1)]
packRecord \"Bq\" [(-1) (-1)]
packRecord \"bq\" [(-1) (-1)]
packRecord \"b\" [(-1)]
packRecord \"b\" [(-1)]
packRecord \"b\" [(-127)]
packRecord \"b\" [(-128)]
packRecord \"b\" [(-129)]
packRecord \"b\" [(-129)]
packRecord \"b\" [(-129)]
packRecord \"b\" [(-129)]
packRecord \"b\" [(-128)]
packRecord \"b\" [(-127)]
packRecord \"b\" [(-1)]
packRecord \"b\" [(1]
packRecord \"b\" [1]
packRecord \"b\" [1]
packRecord \"b\" [1]
packRecord \"b\" [1]
packRecord \"b\" [1]
packRecord \"b\" [1]
packRecord \"b\" [128]
packRecord \"b\" [127]
packRecord \"b\" [-127]
packRecord \"b\" [-128]
packRecord \"b\" [-128]
packRecord \"b\" [-128]
packRecord \"b\" [-129]
packRecord \"b\" [-127]
packRecord \"b\" [-125]
packRecord \"b\" [-126]
packRecord \"b\" [-125]
packRecord \"b\" [1]
packRecord \"b\" [255]
packRecord \"B\" [255]
packRecord \"B\" [256]
packRecord \"B\" [0]
packRecord \"B\" [(-1)]
packRecord \"I\" [(-1)]
packRecord \"Q\" [(-1)]
packRecord \"Q\" [(-1)]
packRecord \"Q\" [(-1)]
packRecord \"Q\" [(-1)]
packRecord \"Q\" [(-1)]
packRecord \"Q\" [(-1)]
packRecord 
packRecord \"i\" [1]
packRecord \"x\" [1]
packRecord \"p\" [1]
packRecord \"p\" [\"hello\"]
packRecord \"p\" [\"hello\"]
packRecord \"p\" [1]
packRecord \"p\" [[]]
packRecord \"p\" [1]
packRecord \"p\" [2]
packRecord \"p\" [3]
packRecord \"p\" [\"a\"]
packRecord \"P\" [[]]
packRecord \"P\" [[]]
packRecord \"f\" [[]]
packRecord \"f\" [[]]
packRecord \"f\" [[]]
packRecord \"f\" [1]
packRecord \"f\" [1.1]
packRecord \"f\" [1.1]
packRecord \"f\" [1.1]
packRecord \"f\" [1.1]
packRecord \"f\" [1.1]
packRecord \"f\" [1.1]
packRecord \"f\" [1.1]
unpackRecord \"f\" (packRecord \"f\" [1.1])
unpackRecord \"i\" (packRecord \"f\" [1.1])
unpackRecord \"i\" (packRecord \"f\" [1.1])
unpackRecord \"f\" (packRecord \"f\" [1.1])
unpackRecord \"f\" (packRecord \"f\" [1.1])
unpackRecord \"f\" (packRecord \"f\" [1.1])
unpackRecord \"f\" (packRecord \"f\" [1.1])
unpackRecord \"d\" (packRecord \"d\" [1.1])
unpackRecord \"d\" (packRecord \"f\" [1.1])
unpackRecord \"d\" (packRecord \"f\" [1.1])
unpackRecord \"d\" (packRecord \"f\" [1.1])
unpackRecord \"f\" (packRecord \"f\" [1.1])
packRecord \"p\" [\"hello\"]
packRecord \"p\" [\"hello\"]
packRecord \"p\" [\"hello\"]
packRecord \"[p]\" []
packRecord \"[p]\" [[]]
packRecord \"[p]\" [[\"a\", \"b\"]]
packRecord \"[p]\" [[\"a\" \"b\"]]
packRecord \"[p]\" [\"a\" \"b\"]
packRecord \"[p]\" [[\"a\" \"b\"]]
packRecord \"[p]\" [[\"a\" \"b\"]]
packRecord \"[p]\" [[\"a\" \"b\"]]
packRecord \"[p]\" [[\"a\" \"b\"]]
packRecord \"[p]\" [[[\"a\"] [\"b\"]]]
packRecord \"[p]\" [[[\"a\"] [\"b\"]]]
packRecord \"[p]\" [[[\"a\"] [\"b\"]]]
packRecord \"i[p]\" [1 [[\"a\"] [\"b\"]]]
packRecord \"i[pi]\" [1 [[\"a\"] [\"b\"]]]
POSIX.exec
POSIX.execv
POSIX.execvp
run $ POSIX.execvp \"ls\" [\"ls\"]
packRecord \"[p]P\" [] []
packRecord \"P\" [] []
packRecord \"P\" []
packRecord \"P\" []
run $ POSIX.execvp \"ls\" [\"ls\"]
packRecord \"P\" []
packRecord \"P\" []
packRecord \"P\" []
packRecord \"P\" [[]]
run $ POSIX.execvp \"ls\" [\"ls\"]
(packRecord \"[p]P\" [(map (\\i [i]) args) []])
(packRecord \"[p]P\" [(map (\\i i) args) []])
[]
map (\\i i) []
[map (\\i i) []]
[(map (\\i i) [])]
[(id 1)]
[(id 1 2)]
[(id 1 \"a\")]
[(id 1 \"a\")]
[(2+3)]
[(2 + id 3)]
[(id 2 + id 3)]
[(map (\\i i) [])]
(map (\\i i) [])
[(map (\\i i) [])]
[(map id [])]
[(map (\\i i) [])]
[(map (\\\\i i) [])]
[(map (\\\\i i) [])]
[(map (\\i i) [])]
[(map (\\i i) [])]
()
id ()
id ()
()
()
id ()
()
()
run $ POSIX.execvp \"ls\" [\"ls\"]
run $ POSIX.execvp \"ls\" [\"ls\"]
[]
(packRecord \"[p]P\" [(map (\\i [i]) args) []) 
(packRecord \"[p]P\" [(map (\\i [i]) args) []) 
run $ POSIX.execvp \"ls\" [\"ls\"]
(packRecord \"[p]P\" [(map (\\i [i]) args) []])
(packRecord \"[p]P\" [(map (\\i [i]) []) []])
(packRecord \"[p]P\" [(map (\\i [i]) [1]) []])
(packRecord \"[p]P\" [(map (\\i [i]) [\"a\"]) []])
requireSharedLibrary fileName 'Cipp \"execvp\" progName (packRecord \"[p]P\" [(map (\\i [i]) args) []])
requireSharedLibrary \"/lib/x86_64-linux-gnu/libc.so.6\"  'Cipp \"execvp\" progName (packRecord \"[p]P\" [(map (\\i [i]) args) []])
requireSharedLibrary \"/lib/x86_64-linux-gnu/libc.so.6\"  'Cipp \"execvp\" \"X\" (packRecord \"[p]P\" [(map (\\i [i]) args) []])
requireSharedLibrary \"/lib/x86_64-linux-gnu/libc.so.6\"  'Cipp \"execvp\" \"X\" (packRecord \"[p]P\" [(map (\\i [i]) []) []])
run (POSIX.execvp \"ls\" [\"ls\"])
[\"ls\"]
run (POSIX.execvp \"ls\" [ \"ls\" ])
run (POSIX.execvp \"ls\" [ \"ls\" ])
run (POSIX.execvp \"ls\" [ \"ls\" ])
run (POSIX.execvp \"ls\" [ \"ls\" ])
POSIX.exports
POSIX.ttyname
run $ POSIX.ttyname
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
run $ POSIX.ttyname 1
POSIX
POSIX.exports
POSIX.tmpfile
POSIX.tmpfile \"A\"
run $ POSIX.tmpfile \"A\"
run $ POSIX.tmpfile
run (POSIX.tmpfile ;\\f fwrite \"hello\" 5 1 f)
run (POSIX.tmpfile ;\\f POSIX.fwrite \"hello\" 5 1 f)
run (POSIX.tmpfile ;\\f POSIX.fwrite \"hello\" 5 1 f ;\\_ POSIX.fflush f)
POSIX.exports
[]
[2 3 4 ]
[2 3 4]
[2 3 4]
[2 3 4]
[2 3 4]
[2 3 4]
POSIX.exports
run $ POSIX.rename \"a\" \"b\"
run $ POSIX.rename \"a\" \"b\"
run $ POSIX.rename \"a\" \"b\"
run $ POSIX.rename \"a\" \"b\"
run $ POSIX.rename \"a\" \"b\"
run $ POSIX.rename \"a\" \"b\"
POSIX.exports
POSIX.pipe
run $ POSIX.pipe
run $ POSIX.pipe
run $ POSIX.pipe
\"a\"
\"a\"
5
2
2
5 + 43242
5 + 43242 + 141
5 + 43242 + 141
5 + 43242 + 141.22
\"a
\"a\"
\"TY\"
duplicateRecord \"TY\"
duplicateRecord \"TY\"
run $ duplicateRecord \"TY\"
65 + 2
65 + 2
65 + 2 + 222
5 + 2
5 + 2
5 + 2.65
run (POSIX.time [] ;\\t POSIX.localtime t)
5 + 2
5⋅3
5⋅3 + 5
5 + 2
5 + 2
5 + 2⋅3⋅4
5 + 2⋅3⋅4.4
5 + 2⋅3⋅4.4 + 2
\"hello\"
strcat \"hello\" \"you\"
strcat \"hello\" \"you\"
strcmp
POSIX.strcmp
run $ POSIX.strcmp \"a\" \"b\"
run $ POSIX.strcmp \"b\" \"b\"
run $ POSIX.strcmp \"b\" \"a\"
5 + 2
5 + 2.5
5 + 2.5 + 5552
5 + 2.5 + 5552
5/2
5/2
5 + 2
5 + 2 + 3
5 + 2 + 444
5 + 2 + 4441
4 + 42
zip [1 2] [3 4]
zip [1 2] [3 4]
zip [1 2] [3 4]
zip [1 2] [3 4]
zip [1 2] [3 4]
drop 2 [1 2 3 4]
5.3⋅2
5.3*2
5.3*2
5.3⋅2
5.3⋅⋅2
5.3⋅2
5.3⋅5
5.3⋅5 + 444
sqrt
√
5 + 2
'x
'y
5 + 2
5 + 2
5 + 2.3
5 + 2.3.5
5 + 2.3.5
5
5 + 2
POSIX.exports
2.3
2.3 + 4
2.3 + 4
zip [[1 2] [3 4]
zip [[1 2] [3 4]]
zip [1 2] [3 4]
POSIX.dup
POSIX.exports
zip [[1 2] [3 4]
zip [[1 2] [3 4]]
zip [1 2] [3 4]
POSIX.dup
POSIX.dup
POSIX.dup
POSIX.exports
zip [[1 2] [3 4]]
zip [[1 2] [3 4]]
POSIX.dup
5 + 2
5 + 2 + 42
5 + 2 + 42.3
5 + 2 + 42.33
5 + 2 + 42.33
5 + 2
9.8
5 + 2 + 42.33
describe 'map
describe 'compose
describe 'foldr
describe 'foldr
5 + 2 + 42.33
5 + 2 + 42.33
5 + 2 + 42.33 + 111
POSIX
POSIX.exports
GTK.exports
GTK2.exports
libxml2.exports
drop 2 [65 5 322 1]
drop 2 [65 5 322 1]
drop 5 [65 5 322 1]
drop 1 [65 5 322 1]
drop 2 [65 5 322 1]
drop 3 [65 5 322 1]
drop 4 [65 5 322 1]
take 4 [65 5 322 1]
take 1 [65 5 322 1]
describe 'take
describe take
describe 'take
describe 'drop
describe 'zip
describe 'zipBy
zip [1 2] [3 4]
OS
OS.exports
OS.exports
OS
OS.exports
OS.open
5 + 2
5 + 2
5 + 2
5 + 2
POSIX.exports
run $ POSIX.puts \"hello\"
5 + 2
5 + 2.3
5 + 2.3 + 4
5 + 2.3 + 4.42.2
run $ absolutePath \"\"
run $ absolutePath []
run $ absolutePath \"..\"
run $ absolutePath \"../..\"
run $ absolutePath \"/\"
run $ absolutePath \"/\"
run $ absolutePath \"22\"
run $ absolutePath \"22221\"
absolutePath? \"22221\"
absolutePath? \"/22221\"
absolutePath? \"2/2221\"
absolutePath? \"\\\\x\"
OS.exports
OS.rename
5 + 2
5 + 2.5
5 + 2.5 + 4242
int0
range 0 10 1
range 0 10 1
range 0 10 5
range 0 10 3
duplicateRecord 
duplicateRecord \"A\"
run $ duplicateRecord \"A\"
write stdout \"AAAA\"
run $ write stdout \"AAAA\"
run $ write stdout \"AAAA\"
run $ write stdout []
run $ write stdout \"\"
run $ write stdout []
run $ write stdout []
run $ write stdout \"\"
run $ write stdout []
run $ write stdout []
run $ write stdout \"hello\"
run $ write stdout \"he\"
unpackRecord \"ii\" [1 2]
unpackRecord \"ii\" \"aaaaaaaa\"
unpackRecord \"p\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"
unpackRecord \"p\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x\"
unpackRecord \"p\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"
unpackRecord \"p\" \"\\x00\"
unpackRecord \"p\" \"a\"
unpackRecord \"p\" \"aaaaaaaaaaaaaa\"
unpackRecord \"p\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"
unpackRecord \"P\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"
unpackRecord \"P\" \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"
run  $ int0
archDepLibName 
archDepLibName \"a\"
archDepLibName \"a\"
Y
rec
take
listFromStr \"a\"
listFromStr \"abc\"
listFromStr \"abcd\"
listFromStr \"abcd\"
listFromStr \"abcd\"
POSIX.exports
GLib
POSIX.fopen
POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
run $ POSIX.fopen \"A\" \"w\"
ls
div 6 2
div 6 1
div 6 0
div 6 1111
div 6 (-2)
run $ POSIX.fopen \"A\" \"w\"
div 6 1
reverse [5 4 3 2 1]
take 5 [2 3 4 2 2 2 2 2 2]
range 1 10 1
range 1 10
range 1 10 1
range 1 10
'range 1 10
'x x
'x 'x
'x 'x
'x
'x 'x
'x 'x
'x 'x
'x 'x
'x 'x
'x 'x
'x 'x
'x 'y
'x 'y
'f + 1
'
'=
'=
'(=)
'=
'=
'(=)
describe '(;)
()_
()
(1)
(a)
(=)
(')
describe '(')
describe '(=)
describe '(=)
drop 2 [2 21]
take 2 [5 4 3 2 1 ]
take 2 [5 4 3 2 1 0]
take 2 []
drop 2 []
drop 2 []
'f + 2
'f + 'g
'f + 'g - 'h
'f + 'g - 'h
'f + 'g + 'h
'f + 'g + 'h
'f + 'g + 'h + 8
8 + 7 + 'f + 'g + 'h + 8
8 + 7 + 'f + 'g + 'h + 8
8 + 7 + 'f + 'g + 'h + 8
8 + 7 + 'f + 'g + 'h + 8
8 + 7 + 'f + 'g + 'h + 8
8 + 7.8 + 'f + 'g + 'h + 8
8 + 7.8e3 + 'f + 'g + 'h + 8
8 + 7.8 + 'f + 'g + 'h + 8
4⋅8
4⋅8
2 + 2
2 + 2 + 55
2 + 2 + 55 + 55555
2 + 2 + 55 + 55555.1
5 + 2
5 + 2⋅4⋅4⋅4
5 + 2⋅4⋅4⋅4 + 42
define f \\x x * x
f 5 + 2
f 5⋅2
f 5⋅2 + 2
f(5) + 2
zip [1 2 3] [4 5 6]
range 1 10 1
allocateRecord 
allocateRecord \"A\"
run $ allocateRecord \"A\"
run $ allocateRecord \"i\"
run $ allocateRecord \"i\"
run $ allocateRecord \"ii\"
run $ allocateRecord \"p\"
run $ allocateRecord \"p\"
5 + 2
5 + 2 + 141
2 + 52
2 + 52 + 44441
5 + 2
5 + 2 + 424
5 + 2 + 424 + 2
1/2
4/5
define sin \\x x + x*x*x/6 + x*x*x*x*x/120
sin 0.8
define sin \\x x + x*x*x/6 + x*x*x*x*x/120 + x*x*x*x*x*x*x/(120*6*7)
sin 0.8
sin 0.1
sin 0.2
define sin \\x x - x*x*x/6 + x*x*x*x*x/120 - x*x*x*x*x*x*x/(120*6*7)
sin 0.1
sin 021
sin 0.2
sin 0.5
sin 0.7
sin 0.8
sin 0.9
sin 1
sin 3.141592
pi
sin 3.141592653589793
define pi 3.141592653589793
pi
define cos \\x 1 - x*x/2 + x*x*x*x/24
cos 0.1
cos 0.5
cos 1
define cos \\x 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720
cos 0.5
cos 0.1
cos 0.2
cos 0.3
cos 0.4
cos 0.5
cos 1
cos 3.141592
cos 3.141592/2
cos pi/2
define π pi
π
cos ϑ
cos π
cos π
s
s
1
2
3
4
5
define tan \\x (sin x)/(cos x)
tan 0.2
tan 0.3
tan 0.4
tan 1
tan 42
tan 1000
tan (1000 % 6.28)
tan (1000 % (2 * pi))
define tan \\x tan (x % (2 * pi))
tan 1000
tan 2000
define sin \\xx let x = (xx % (2 * pi)) in x - x*x*x/6 + x*x*x*x*x/120 - x*x*x*x*x*x*x/(120*6*7)
define cos \\xx let x = (xx % (2 * pi)) in 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720
define tan \\x (sin x)/(cos x)
sin 500
sin 50
sin 51
sin 1
sin 2
sin 3
sin 4
define sin \\xx let x = (xx) in x - x*x*x/6 + x*x*x*x*x/120 - x*x*x*x*x*x*x/(120*6*7)
sin 4
define sin \\xx let x = (xx % pi) in x - x*x*x/6 + x*x*x*x*x/120 - x*x*x*x*x*x*x/(120*6*7)
sin 4
define sin \\xx let x = (xx % (2.0 * pi)) in x - x*x*x/6 + x*x*x*x*x/120 - x*x*x*x*x*x*x/(120*6*7)
sin 4
define sin \\xx let sin = (\\x x - x*x*x/6 + x*x*x*x*x/120 - x*x*x*x*x*x*x/(120*6*7)) in let x = (xx % (2 * pi)) in if (x >= pi) (-(sin (x % pi))) (sin x)
sin 4
sin 0
sin 1
sin (-1)
sin (-2)
define cos \\xx let x = (xx % (pi)) in 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720
cos 0
cos 0.1
cos 0.2
cos 0.3
cos 0.4
cos 0.5
cos 4
define cos \\xx let x = (xx % (pi)) in let cos = (\\x 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720) in if (x >= pi) (-(cos (x % pi))) (cos x)
cos 4
define cos \\xx let x = (xx % (pi)) in let cos = (\\x 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720) in if (x >= pi) ((cos (x % pi))) (cos x)
cos 4
define cos \\xx let x = (xx % (pi)) in let cos = (\\x 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720) in if (x >= pi) (-(cos (x % pi))) (cos x)
cos 4
define cos \\xx let x = (xx % (2 * pi)) in let cos = (\\x 1 - x*x/2 + x*x*x*x/24 - x*x*x*x*x*x/720) in if (x >= pi) (-(cos (x % pi))) (cos x)
cos 4
cos 4
cos 5
cos 500
cos 5000
tan
define tan \\x (sin x) / (cos x)
tan 400
tan (-400)
tan (-4000)
OS
OS.rename
OS.exports
OS.exports
div 5 2
div 5 2
div 5 2
div 5 2
div 5 2
2 + 5
2 + 5
2 + 5
2 + 5
2 + 5
2 + 5
2 + 5
2 + 5
2 + 5
sin 5
strFromList 
strFromList [65 66 67 68]
strFromList [65 66 67 68 1]
strFromList [65 66 67 68 1 0]
tan 2
sin 1
sin 2
sin 3
sin 55
run $ readline 5
POSIX.exports
[5 4 3] ++ [2 3 4]
recordSize \"i\"
recordSize \"p\"
recordSize \"P\"
recordSize \"x\"
write stdout \"hello\"
run $ write stdout \"hello\"
2%0
4040399999595960*55555555555
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
recordSize \"iiiiiiiiilZ\"
recordSize \"iiiiiiiiil\"
recordSize \"iiiiiiiiilZ\"
recordSize \"iiiiiiiiilz\"
recordSize \"iiiiiiiiilz\"
recordSize \"iiiiiiiiilZ\"
recordSize \"iiiiiiiiil\"
run (POSIX.time [] ;\\t POSIX.localtime t)
recordSize \"iiiiiiiiilZ\"
recordSize \"iiiiiiiii\"
recordSize \"iiiiiiiii\"
recordSize \"iiiiiiiii\"
recordSize \"iiiiiiiii\"
recordSize \"iiiiiiiii\"
recordSize \"iiiiiiiii\"
4 + 4
4 + 4
4 + 4 + 2
4 + 4 + 2
run (POSIX.time [] ;\\t POSIX.localtime t)
'x
'x + x
'x + 'x
'x + ''x
'x + ''
'x + ''x
''x
'''''x
''x
'x
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
run (POSIX.time [] ;\\t POSIX.localtime t)
enumerate
define enumerate \\list zip (range 0 (length list) 1) list
enumerate [2 3 4]
enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t)
map (\\e (head (tail e)) + if ((head e) = 4) 1 0) enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t)
map (\\e (head (tail e)) + if ((head e) = 4) 1 0) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
map (\\e (head (tail e)) + let index = (head e) in if (index = 4) 1 0) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
map (\\e (head (tail e)) + let index = (head e) in if (index = 4) 1 (if index = 5) 1900 0) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
map (\\e (head (tail e)) + let index = (head e) in (if (index = 4) 1 (if index = 5) 1900 0)) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
map (\\e (head (tail e)) + let index = (head e) in (if (index = 4) 1 (if (index = 5) 1900 0) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
map (\\e (head (tail e)) + let index = (head e) in (if (index = 4) 1 (if (index = 5) 1900 0)) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
map (\\e (head (tail e)) + let index = (head e) in (if (index = 4) 1 (if (index = 5) 1900 0))) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
map (\\e let value = (head (tail e)) in let index = (head e) in (if (index = 4) (value + 1) (if (index = 5) (value + 1900) value))) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
enumerate 
enumerate [2 3 4]
5⋅4⋅3⋅2
5⋅4⋅3⋅2 + 42
map (\\e let value = (head (tail e)) in let index = (head e) in (if (index = 4) (value + 1) (if (index = 5) (value + 1900) value))) (enumerate $ run (POSIX.time [] ;\\t POSIX.localtime t))
5 + 2
5 + 2⋅65
errno
run $ errno
5 + 2
5 + 2
5 + 2
5 + 2
POSIX.errno
POSIX.errno
errno
5 + 5
5 + 5
5 + 5
5 + 5
errno
run $ errno
run errno
run errno
run errno
run errno
run errno
run errno
run errno
run errno
run errno
run errno
run errno
run errno
999999999999
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
999999999999 + 2
duplicateRecord \"A\"
run $ duplicateRecord \"AA\"
run$ duplicateRecord \"AA\"
run$ duplicateRecord \"AA\" ;\\x liftIO x
run$ (duplicateRecord \"AA\" ;\\x liftIO x)
run$ (duplicateRecord \"AA\" ;\\x liftIO x)
run$ (duplicateRecord \"AA\" ;\\x liftIO x)
run$ (duplicateRecord \"AA\" ;\\x liftIO x)
run$ (duplicateRecord \"AA\" ;\\x liftIO x)
2 + 5
2 + 5
2 + 5
5 + 42
factorial 55
factorial 99
factorial 199
\"hello\\nworld\"
5 + 42
5 + 42
5 + 42
5 + 42
5 + 42
5 + 42
OS.exports
POSIX.exports
OS.exports
POSIX.exports
OS.exports
POSIX.exports
+2
0+2
0+2
+2
+2
+2
-2
-2
+2
+2
-2
3 + 2
3 + 2⋅5⋅4⋅3
factorial 123
factorial 123
POSIX.syslog
errno
5 + 2
5 + 2 + 4444
5 + 2 + 4444.2
5 + 2 + 4444.2 + 66666
5 + 2 + 4444.2 + 66666.2
POSIX.vsyslog
syslog
POSIX.syslog
run $ POSIX.syslog 
run $ POSIX.syslog 1 \"%s\" \"hello\"
POSIX
POSIX.syslog
POSIX.syslog 1 \"%s\" \"hello\"
run $ POSIX.syslog 1 \"%s\" \"hello\"
run $ POSIX.syslog 1 \"%s\" \"hello\"
run $ POSIX.syslog 1 \"\"hello\"
run $ POSIX.syslog 1 \"hello\"
run $ POSIX.syslog 1 \"hello\"
run $ POSIX.syslog 1 \"hello\"
run $ POSIX.syslog 1 \"hello\"
run $ POSIX.syslog 1 \"hello\"
run $ POSIX.syslog 1 \"hello\"
run $ POSIX.syslog 1 \"helloaaa\"
run $ POSIX.syslog 1 \"\"
run $ POSIX.syslog 1 \"L\"
5 + 4
5 + 4
5 + 4
5 + 2
5 + 2
5 + 2
if
define repeat \\f rec \\repeat \\a a:(repeat (f a))\\f rec (\\repeat \\a a:(repeat (f a)))
define within \\eps rec \\within \\list let a = head list in let b = head (tail list) in if (abs (a - b) <= eps) b (within (b:(tail (tail list))))
define abs \\x if (x <= 0) (-x) x
define within \\eps rec \\within \\list let a = head list in let b = head (tail list) in if (abs (a - b) <= eps) b (within (b:(tail (tail list))))
define sqrt \\a0 \\eps \\N within eps (repeat (next N) a0)
define next \\N \\x (x + N/x) / 2
define sqrt \\a0 \\eps \\N within eps (repeat (next N) a0)
sqrt 1 0.001 9
abs 2
abs (-2)
next 1 2
sqrt 1 0.001 9
sqrt
within
repeat
head (repeat (next 9) 1)
define repeat \\f rec \\repeat \\a a:(repeat (f a))
define sqrt \\a0 \\eps \\N within eps (repeat (next N) a0)
sqrt 1 0.001 9
42
") environment) ((\if 
((\id 
((\else 
((\otherwise 
((\$ 
((\&& 
((\|| 
((\not 
((\< 
((\flip 
((\> 
((\Y 
((\rec 
((\foldr 
((\foldl 
((\compose 
((\map 
((\++ 
((\= 
((\δ 
((\reverse 
((\foldl 
((\reverse 
((\| 
((\/= 
((\>= 
((\≤ 
((\≥ 
((\div 
((\mod 
((\% 
((\ioWorld 
((\ioValue 
((\liftIO 
((\lift 
((\runIOxx 
((\; 
((\implies? 
((\equivalent? 
((\take 
((\drop 
((\rangeLL 
((\rangeLL 
((\range 
((\range1 
((\zipBy 
((\zip 
((\length 
((\filter 
((\toBool 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeSortBy 
((\mergeSortBy 
((\mergeSort 
((\factorial 
((\merge 
((\assq 
((\assq 
((\assq 
((\assq 
((\dispatchModulexxx 
((\POSIX 
((\return 
((\. 
((\. 
((\run 
((\OS 
((\POSIX 
((\OS 
((\f 
((\sin 
((\sin 
((\sin 
((\pi 
((\cos 
((\cos 
((\π 
((\tan 
((\tan 
((\sin 
((\cos 
((\tan 
((\sin 
((\sin 
((\sin 
((\sin 
((\cos 
((\cos 
((\cos 
((\cos 
((\cos 
((\tan 
((\enumerate 
((\repeat 
((\abs 
((\within 
((\next 
((\sqrt 
((\repeat 
((\sqrt 
nil) (\a0 
(\eps 
(\N 
((within eps) ((repeat (next N)) a0))))))) (\f 
(rec (\repeat 
(\a 
((: a) (repeat (f a))))))))) (\a0 
(\eps 
(\N 
((within eps) ((repeat (next N)) a0))))))) (\N 
(\x 
((/ ((+ x) ((/ N) x))) 2))))) (\eps 
(rec (\within 
(\list 
((\a 
((\b 
(((if ((<= (abs ((- a) b))) eps)) b) (within ((: b) (tail (tail list)))))) (head (tail list)))) (head list)))))))) (\x 
(((if ((<= x) 0)) ((- 0) x)) x)))) (\f 
(rec (\repeat 
(\a 
(((: a) (repeat (f a))) (\f 
(rec (\repeat 
(\a 
((: a) (repeat (f a)))))))))))))) (\list 
((zip (((range 0) (length list)) 1)) list)))) (\x 
((/ (sin x)) (cos x))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) ((* 2) pi)))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) (cos ((% x) pi))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))) ((% xx) pi))))) (\xx 
((\sin 
((\x 
(((if ((>= x) pi)) ((- 0) (sin ((% x) pi)))) (sin x))) ((% xx) ((* 2) pi)))) (\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) ((* 2.0) pi)))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) pi))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) xx)))) (\x 
((/ (sin x)) (cos x))))) (\xx 
((\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))) ((% xx) ((* 2) pi)))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) ((* 2) pi)))))) (\x 
(tan ((% x) ((* 2) pi)))))) (\x 
((/ (sin x)) (cos x))))) 3.141593)) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) (\x 
((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))))) 3.141593)) (\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))) (\x 
((+ ((+ ((+ x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))) (\x 
((+ ((+ x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))))) (\x 
((* x) x)))) (requireModule "/usr/share/5D/OS/init.5D"))) (requireModule "/usr/share/5D/POSIX/init.5D"))) (requireModule "/usr/share/5D/OS/init.5D"))) runIO)) (\a 
(\b 
(a b))))) ')) (\v 
(\world 
((: v) ((: world) nil)))))) (requireModule "/usr/share/5D/POSIX/POSIX.5D"))) (\list 
(\key 
((| ((| ((assq key) list)) tail)) head))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head (head alist))) key)) (head alist))) (else (assq (tail alist))))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head alist)) key)) (head alist))) (else (assq (tail alist))))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head alist)) key)) (head alist))) ((else assq) (tail alist)))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ ((if ((symbolsEqual? (head assq)) key)) (head assq))) (assq (tail alist)))))))))) (mergeBy <=))) (rec (\fac 
(\v 
(((if ((= v) 0)) 1) ((* v) (fac ((- v) 1))))))))) (mergeSortBy <=))) (\lessEqualComparator 
(rec (\mergeSortBy 
(\list 
(($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeBy) lessEqualComparator) (mergeSortBy ((take ((div (length list)) 2)) list))) (mergeSortBy ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator 
(rec (\mergeSortBy 
(\list 
(($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeBy) lessEqualComparator) ((take ((div (length list)) 2)) list)) ((drop ((div (length list)) 2)) list))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((|| (nil? l1)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(((if ((&& (nil? l1)) (nil? l2))) nil) (((if (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2))) (((if ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2))) ((: (head l2)) ((mergeBy l1) (tail l2))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) ((|| (nil? l2)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2))))))))))))) (\v 
(((if v) (' t)) (' f))))) (\f 
(rec (\filter 
(\list 
(($ ((if (nil? list)) nil)) ((((else if) (f (head list))) ((: (head list)) (filter (tail list)))) (filter (tail list)))))))))) (rec (\length 
(\list 
(((if (nil? list)) 0) ((+ 1) (length (tail list))))))))) (zipBy (\x 
(\y 
((: x) ((: y) nil))))))) (\zipper 
(rec (\zipBy 
(\l1 
(\l2 
(($ ((if ((|| (nil? l1)) (nil? l2))) nil)) (else ((: ((zipper (head l1)) (head l2))) ((zipBy (tail l1)) (tail l2)))))))))))) (\beginning 
(\end 
(((rangeLL 1) end) beginning))))) (\beginning 
(\end 
(\step 
(((rangeLL step) end) beginning)))))) (\step 
(\end 
(rec (\rangeLL 
(\beginning 
(((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (\step 
(\end 
(rec (\rangeLL 
(\beginning 
(((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (rec (\drop 
(\count 
(\list 
(((if ((|| ((<= count) 0)) (nil? list))) list) ((drop ((- count) 1)) (tail list))))))))) (rec (\take 
(\count 
(\list 
(((if ((|| ((<= count) 0)) (nil? list))) nil) ((: (head list)) ((take ((- count) 1)) (tail list)))))))))) (\a 
(\b 
((|| ((&& a) b)) ((&& (not a)) (not b))))))) (\a 
(\b 
((|| (not a)) b))))) (\m 
(\ber 
(\world 
((\r 
((ber (ioValue r)) (ioWorld r))) (m world))))))) (\m 
(ioValue (id m))))) liftIO)) (\v 
(\world 
((: v) ((: world) nil)))))) (\m 
(head m)))) (\m 
(head (tail m))))) mod)) (\a 
(\b 
(head (tail ((divmod a) b))))))) (\a 
(\b 
(head ((divmod a) b)))))) >=)) <=)) (\a 
(\b 
((<= b) a))))) (\a 
(\b 
(not ((= a) b)))))) (\a 
(\b 
(b a))))) (\list 
(((foldl (flip :)) nil) list)))) (\f 
(rec (\foldl 
(\v 
(\list 
(($ ((if (nil? list)) v)) (((else foldl) ((f v) (head list))) (tail list)))))))))) (\list 
(((foldl (flip :)) nil) list)))) (\x 
(((if ((= x) 0)) 1) 0)))) (\a 
(\b 
((&& ((<= a) b)) ((<= b) a)))))) (\a 
(\b 
(((foldr :) b) a))))) (\f 
(\list 
(((foldr ((compose :) f)) nil) list))))) (\f 
(\g 
(\x 
(f (g x))))))) (\f 
(rec (\foldl 
(\v 
(\list 
(($ ((if (nil? list)) v)) (((else foldl) ((f (head list)) v)) (tail list)))))))))) (\f 
(\v 
(rec (\foldr 
(\list 
(($ ((if (nil? list)) v)) (((else f) (head list)) (foldr (tail list))))))))))) Y)) (\f 
((\x 
(f (x x))) (\x 
(f (x x))))))) (flip <))) (\f 
(\a 
(\b 
((f b) a)))))) (\a 
(\b 
((&& ((<= a) b)) (not ((<= b) a))))))) (\a 
(\t 
(\f 
((a f) t)))))) (\a 
(\b 
(\t 
(\f 
((a t) ((b t) f)))))))) (\a 
(\b 
(\t 
(\f 
((a ((b t) f)) f))))))) (\a 
(\b 
(a b))))) id)) id)) (\keywordFromStr 
((\strFromKeyword 
((\listFromStr 
((\strFromList 
((\substr 
((\strUntilZero 
((\runIO 
((\#t 
((\#f 
((\stdin 
((\stdout 
((\stderr 
((\write 
((\flush 
((\readline 
((\messageBox 
((\requireSharedLibrary 
((\absolutePath 
((\absolutePath? 
((\packRecord 
((\unpackRecord 
((\recordSize 
((\allocateRecord 
((\duplicateRecord 
((\archDepLibName 
((\errno 
((\if 
((\id 
((\else 
((\otherwise 
((\$ 
((\&& 
((\|| 
((\not 
((\< 
((\flip 
((\> 
((\Y 
((\rec 
((\foldr 
((\foldl 
((\compose 
((\map 
((\++ 
((\= 
((\δ 
((\reverse 
((\foldl 
((\reverse 
((\| 
((\/= 
((\>= 
((\≤ 
((\≥ 
((\div 
((\mod 
((\% 
((\ioWorld 
((\ioValue 
((\liftIO 
((\lift 
((\runIOxx 
((\; 
((\implies? 
((\equivalent? 
((\take 
((\drop 
((\rangeLL 
((\rangeLL 
((\range 
((\range1 
((\zipBy 
((\zip 
((\length 
((\filter 
((\toBool 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeSortBy 
((\mergeSortBy 
((\mergeSort 
((\factorial 
((\merge 
((\assq 
((\assq 
((\assq 
((\assq 
((\dispatchModulexxx 
((\POSIX 
((\return 
((\. 
((\. 
((\run 
((\OS 
((\POSIX 
((\OS 
((\f 
((\sin 
((\sin 
((\sin 
((\pi 
((\cos 
((\cos 
((\π 
((\tan 
((\tan 
((\sin 
((\cos 
((\tan 
((\sin 
((\sin 
((\sin 
((\sin 
((\cos 
((\cos 
((\cos 
((\cos 
((\cos 
((\tan 
((\enumerate 
((\repeat 
((\abs 
((\within 
((\next 
((\sqrt 
((\repeat 
((\sqrt 
42) (\a0 
(\eps 
(\N 
((within eps) ((repeat (next N)) a0))))))) (\f 
(rec (\repeat 
(\a 
((: a) (repeat (f a))))))))) (\a0 
(\eps 
(\N 
((within eps) ((repeat (next N)) a0))))))) (\N 
(\x 
((/ ((+ x) ((/ N) x))) 2))))) (\eps 
(rec (\within 
(\list 
((\a 
((\b 
(((if ((<= (abs ((- a) b))) eps)) b) (within ((: b) (tail (tail list)))))) (head (tail list)))) (head list)))))))) (\x 
(((if ((<= x) 0)) ((- 0) x)) x)))) (\f 
(rec (\repeat 
(\a 
(((: a) (repeat (f a))) (\f 
(rec (\repeat 
(\a 
((: a) (repeat (f a)))))))))))))) (\list 
((zip (((range 0) (length list)) 1)) list)))) (\x 
((/ (sin x)) (cos x))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) ((* 2) pi)))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) (cos ((% x) pi))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))) ((% xx) pi))))) (\xx 
((\sin 
((\x 
(((if ((>= x) pi)) ((- 0) (sin ((% x) pi)))) (sin x))) ((% xx) ((* 2) pi)))) (\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) ((* 2.0) pi)))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) pi))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) xx)))) (\x 
((/ (sin x)) (cos x))))) (\xx 
((\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))) ((% xx) ((* 2) pi)))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) ((* 2) pi)))))) (\x 
(tan ((% x) ((* 2) pi)))))) (\x 
((/ (sin x)) (cos x))))) 3.141593)) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) (\x 
((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))))) 3.141593)) (\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))) (\x 
((+ ((+ ((+ x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))) (\x 
((+ ((+ x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))))) (\x 
((* x) x)))) (requireModule "/usr/share/5D/OS/init.5D"))) (requireModule "/usr/share/5D/POSIX/init.5D"))) (requireModule "/usr/share/5D/OS/init.5D"))) runIO)) (\a 
(\b 
(a b))))) ')) (\v 
(\world 
((: v) ((: world) nil)))))) (requireModule "/usr/share/5D/POSIX/POSIX.5D"))) (\list 
(\key 
((| ((| ((assq key) list)) tail)) head))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head (head alist))) key)) (head alist))) (else (assq (tail alist))))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head alist)) key)) (head alist))) (else (assq (tail alist))))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head alist)) key)) (head alist))) ((else assq) (tail alist)))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ ((if ((symbolsEqual? (head assq)) key)) (head assq))) (assq (tail alist)))))))))) (mergeBy <=))) (rec (\fac 
(\v 
(((if ((= v) 0)) 1) ((* v) (fac ((- v) 1))))))))) (mergeSortBy <=))) (\lessEqualComparator 
(rec (\mergeSortBy 
(\list 
(($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeBy) lessEqualComparator) (mergeSortBy ((take ((div (length list)) 2)) list))) (mergeSortBy ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator 
(rec (\mergeSortBy 
(\list 
(($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeBy) lessEqualComparator) ((take ((div (length list)) 2)) list)) ((drop ((div (length list)) 2)) list))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((|| (nil? l1)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(((if ((&& (nil? l1)) (nil? l2))) nil) (((if (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2))) (((if ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2))) ((: (head l2)) ((mergeBy l1) (tail l2))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) ((|| (nil? l2)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2))))))))))))) (\v 
(((if v) (' t)) (' f))))) (\f 
(rec (\filter 
(\list 
(($ ((if (nil? list)) nil)) ((((else if) (f (head list))) ((: (head list)) (filter (tail list)))) (filter (tail list)))))))))) (rec (\length 
(\list 
(((if (nil? list)) 0) ((+ 1) (length (tail list))))))))) (zipBy (\x 
(\y 
((: x) ((: y) nil))))))) (\zipper 
(rec (\zipBy 
(\l1 
(\l2 
(($ ((if ((|| (nil? l1)) (nil? l2))) nil)) (else ((: ((zipper (head l1)) (head l2))) ((zipBy (tail l1)) (tail l2)))))))))))) (\beginning 
(\end 
(((rangeLL 1) end) beginning))))) (\beginning 
(\end 
(\step 
(((rangeLL step) end) beginning)))))) (\step 
(\end 
(rec (\rangeLL 
(\beginning 
(((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (\step 
(\end 
(rec (\rangeLL 
(\beginning 
(((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (rec (\drop 
(\count 
(\list 
(((if ((|| ((<= count) 0)) (nil? list))) list) ((drop ((- count) 1)) (tail list))))))))) (rec (\take 
(\count 
(\list 
(((if ((|| ((<= count) 0)) (nil? list))) nil) ((: (head list)) ((take ((- count) 1)) (tail list)))))))))) (\a 
(\b 
((|| ((&& a) b)) ((&& (not a)) (not b))))))) (\a 
(\b 
((|| (not a)) b))))) (\m 
(\ber 
(\world 
((\r 
((ber (ioValue r)) (ioWorld r))) (m world))))))) (\m 
(ioValue (id m))))) liftIO)) (\v 
(\world 
((: v) ((: world) nil)))))) (\m 
(head m)))) (\m 
(head (tail m))))) mod)) (\a 
(\b 
(head (tail ((divmod a) b))))))) (\a 
(\b 
(head ((divmod a) b)))))) >=)) <=)) (\a 
(\b 
((<= b) a))))) (\a 
(\b 
(not ((= a) b)))))) (\a 
(\b 
(b a))))) (\list 
(((foldl (flip :)) nil) list)))) (\f 
(rec (\foldl 
(\v 
(\list 
(($ ((if (nil? list)) v)) (((else foldl) ((f v) (head list))) (tail list)))))))))) (\list 
(((foldl (flip :)) nil) list)))) (\x 
(((if ((= x) 0)) 1) 0)))) (\a 
(\b 
((&& ((<= a) b)) ((<= b) a)))))) (\a 
(\b 
(((foldr :) b) a))))) (\f 
(\list 
(((foldr ((compose :) f)) nil) list))))) (\f 
(\g 
(\x 
(f (g x))))))) (\f 
(rec (\foldl 
(\v 
(\list 
(($ ((if (nil? list)) v)) (((else foldl) ((f (head list)) v)) (tail list)))))))))) (\f 
(\v 
(rec (\foldr 
(\list 
(($ ((if (nil? list)) v)) (((else f) (head list)) (foldr (tail list))))))))))) Y)) (\f 
((\x 
(f (x x))) (\x 
(f (x x))))))) (flip <))) (\f 
(\a 
(\b 
((f b) a)))))) (\a 
(\b 
((&& ((<= a) b)) (not ((<= b) a))))))) (\a 
(\t 
(\f 
((a f) t)))))) (\a 
(\b 
(\t 
(\f 
((a t) ((b t) f)))))))) (\a 
(\b 
(\t 
(\f 
((a ((b t) f)) f))))))) (\a 
(\b 
(a b))))) id)) id)) (\f 
f))) (\f 
f))) errno)) archDepLibName)) duplicateRecord)) allocateRecord)) recordSize)) unpackRecord)) packRecord)) absolutePath?)) absolutePath)) requireSharedLibrary)) messageBox)) readline)) flush)) write)) stderr)) stdout)) stdin)) (\t 
(\f 
f)))) (\t 
(\f 
t)))) runIO)) strUntilZero)) substr)) strFromList)) listFromStr)) keywordStr)))) (\strFromKeyword 
((\listFromStr 
((\strFromList 
((\substr 
((\strUntilZero 
((\runIO 
((\#t 
((\#f 
((\stdin 
((\stdout 
((\stderr 
((\write 
((\flush 
((\readline 
((\messageBox 
((\requireSharedLibrary 
((\absolutePath 
((\absolutePath? 
((\packRecord 
((\unpackRecord 
((\recordSize 
((\allocateRecord 
((\duplicateRecord 
((\archDepLibName 
((\errno 
((\if 
((\id 
((\else 
((\otherwise 
((\$ 
((\&& 
((\|| 
((\not 
((\< 
((\flip 
((\> 
((\Y 
((\rec 
((\foldr 
((\foldl 
((\compose 
((\map 
((\++ 
((\= 
((\δ 
((\reverse 
((\foldl 
((\reverse 
((\| 
((\/= 
((\>= 
((\≤ 
((\≥ 
((\div 
((\mod 
((\% 
((\ioWorld 
((\ioValue 
((\liftIO 
((\lift 
((\runIOxx 
((\; 
((\implies? 
((\equivalent? 
((\take 
((\drop 
((\rangeLL 
((\rangeLL 
((\range 
((\range1 
((\zipBy 
((\zip 
((\length 
((\filter 
((\toBool 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeBy 
((\mergeSortBy 
((\mergeSortBy 
((\mergeSort 
((\factorial 
((\merge 
((\assq 
((\assq 
((\assq 
((\assq 
((\dispatchModulexxx 
((\POSIX 
((\return 
((\. 
((\. 
((\run 
((\OS 
((\POSIX 
((\OS 
((\f 
((\sin 
((\sin 
((\sin 
((\pi 
((\cos 
((\cos 
((\π 
((\tan 
((\tan 
((\sin 
((\cos 
((\tan 
((\sin 
((\sin 
((\sin 
((\sin 
((\cos 
((\cos 
((\cos 
((\cos 
((\cos 
((\tan 
((\enumerate 
((\repeat 
((\abs 
((\within 
((\next 
((\sqrt 
((\repeat 
((\sqrt 
42) (\a0 
(\eps 
(\N 
((within eps) ((repeat (next N)) a0))))))) (\f 
(rec (\repeat 
(\a 
((: a) (repeat (f a))))))))) (\a0 
(\eps 
(\N 
((within eps) ((repeat (next N)) a0))))))) (\N 
(\x 
((/ ((+ x) ((/ N) x))) 2))))) (\eps 
(rec (\within 
(\list 
((\a 
((\b 
(((if ((<= (abs ((- a) b))) eps)) b) (within ((: b) (tail (tail list)))))) (head (tail list)))) (head list)))))))) (\x 
(((if ((<= x) 0)) ((- 0) x)) x)))) (\f 
(rec (\repeat 
(\a 
(((: a) (repeat (f a))) (\f 
(rec (\repeat 
(\a 
((: a) (repeat (f a)))))))))))))) (\list 
((zip (((range 0) (length list)) 1)) list)))) (\x 
((/ (sin x)) (cos x))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) ((* 2) pi)))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) (cos ((% x) pi))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((\cos 
(((if ((>= x) pi)) ((- 0) (cos ((% x) pi)))) (cos x))) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) ((% xx) pi))))) (\xx 
((\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))) ((% xx) pi))))) (\xx 
((\sin 
((\x 
(((if ((>= x) pi)) ((- 0) (sin ((% x) pi)))) (sin x))) ((% xx) ((* 2) pi)))) (\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) ((* 2.0) pi)))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) pi))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) xx)))) (\x 
((/ (sin x)) (cos x))))) (\xx 
((\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))) ((% xx) ((* 2) pi)))))) (\xx 
((\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))) ((% xx) ((* 2) pi)))))) (\x 
(tan ((% x) ((* 2) pi)))))) (\x 
((/ (sin x)) (cos x))))) 3.141593)) (\x 
((- ((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))) ((/ ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) 720))))) (\x 
((+ ((- 1) ((/ ((* x) x)) 2))) ((/ ((* ((* ((* x) x)) x)) x)) 24))))) 3.141593)) (\x 
((- ((+ ((- x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))) (\x 
((+ ((+ ((+ x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))) ((/ ((* ((* ((* ((* ((* ((* x) x)) x)) x)) x)) x)) x)) ((* ((* 120) 6)) 7)))))) (\x 
((+ ((+ x) ((/ ((* ((* x) x)) x)) 6))) ((/ ((* ((* ((* ((* x) x)) x)) x)) x)) 120))))) (\x 
((* x) x)))) (requireModule "/usr/share/5D/OS/init.5D"))) (requireModule "/usr/share/5D/POSIX/init.5D"))) (requireModule "/usr/share/5D/OS/init.5D"))) runIO)) (\a 
(\b 
(a b))))) ')) (\v 
(\world 
((: v) ((: world) nil)))))) (requireModule "/usr/share/5D/POSIX/POSIX.5D"))) (\list 
(\key 
((| ((| ((assq key) list)) tail)) head))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head (head alist))) key)) (head alist))) (else (assq (tail alist))))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head alist)) key)) (head alist))) (else (assq (tail alist))))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ (((else if) ((symbolsEqual? (head alist)) key)) (head alist))) ((else assq) (tail alist)))))))))) (\key 
(rec (\assq 
(\alist 
(($ ((if (nil? alist)) nil)) (($ ((if ((symbolsEqual? (head assq)) key)) (head assq))) (assq (tail alist)))))))))) (mergeBy <=))) (rec (\fac 
(\v 
(((if ((= v) 0)) 1) ((* v) (fac ((- v) 1))))))))) (mergeSortBy <=))) (\lessEqualComparator 
(rec (\mergeSortBy 
(\list 
(($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeBy) lessEqualComparator) (mergeSortBy ((take ((div (length list)) 2)) list))) (mergeSortBy ((drop ((div (length list)) 2)) list)))))))))) (\lessEqualComparator 
(rec (\mergeSortBy 
(\list 
(($ ((if ((|| (nil? list)) (nil? (tail list)))) list)) ((((else mergeBy) lessEqualComparator) ((take ((div (length list)) 2)) list)) ((drop ((div (length list)) 2)) list))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((&& (not (nil? l1))) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((|| (nil? l1)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(((if ((&& (nil? l1)) (nil? l2))) nil) (((if (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2))) (((if ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2))) ((: (head l2)) ((mergeBy l1) (tail l2))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) (nil? l2)) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (($ (((else if) ((lessEqualComparator (head l1)) (head l2))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2)))))))))))))) (\lessEqualComparator 
(rec (\mergeBy 
(\l1 
(\l2 
(($ ((if ((&& (nil? l1)) (nil? l2))) nil)) (($ (((else if) ((|| (nil? l2)) ((lessEqualComparator (head l1)) (head l2)))) ((: (head l1)) ((mergeBy (tail l1)) l2)))) (else ((: (head l2)) ((mergeBy l1) (tail l2))))))))))))) (\v 
(((if v) (' t)) (' f))))) (\f 
(rec (\filter 
(\list 
(($ ((if (nil? list)) nil)) ((((else if) (f (head list))) ((: (head list)) (filter (tail list)))) (filter (tail list)))))))))) (rec (\length 
(\list 
(((if (nil? list)) 0) ((+ 1) (length (tail list))))))))) (zipBy (\x 
(\y 
((: x) ((: y) nil))))))) (\zipper 
(rec (\zipBy 
(\l1 
(\l2 
(($ ((if ((|| (nil? l1)) (nil? l2))) nil)) (else ((: ((zipper (head l1)) (head l2))) ((zipBy (tail l1)) (tail l2)))))))))))) (\beginning 
(\end 
(((rangeLL 1) end) beginning))))) (\beginning 
(\end 
(\step 
(((rangeLL step) end) beginning)))))) (\step 
(\end 
(rec (\rangeLL 
(\beginning 
(((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (\step 
(\end 
(rec (\rangeLL 
(\beginning 
(((if ((<= step) ((- 0) 1))) (((if ((<= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step))))) (((if ((>= beginning) end)) nil) ((: beginning) (rangeLL ((+ beginning) step)))))))))))) (rec (\drop 
(\count 
(\list 
(((if ((|| ((<= count) 0)) (nil? list))) list) ((drop ((- count) 1)) (tail list))))))))) (rec (\take 
(\count 
(\list 
(((if ((|| ((<= count) 0)) (nil? list))) nil) ((: (head list)) ((take ((- count) 1)) (tail list)))))))))) (\a 
(\b 
((|| ((&& a) b)) ((&& (not a)) (not b))))))) (\a 
(\b 
((|| (not a)) b))))) (\m 
(\ber 
(\world 
((\r 
((ber (ioValue r)) (ioWorld r))) (m world))))))) (\m 
(ioValue (id m))))) liftIO)) (\v 
(\world 
((: v) ((: world) nil)))))) (\m 
(head m)))) (\m 
(head (tail m))))) mod)) (\a 
(\b 
(head (tail ((divmod a) b))))))) (\a 
(\b 
(head ((divmod a) b)))))) >=)) <=)) (\a 
(\b 
((<= b) a))))) (\a 
(\b 
(not ((= a) b)))))) (\a 
(\b 
(b a))))) (\list 
(((foldl (flip :)) nil) list)))) (\f 
(rec (\foldl 
(\v 
(\list 
(($ ((if (nil? list)) v)) (((else foldl) ((f v) (head list))) (tail list)))))))))) (\list 
(((foldl (flip :)) nil) list)))) (\x 
(((if ((= x) 0)) 1) 0)))) (\a 
(\b 
((&& ((<= a) b)) ((<= b) a)))))) (\a 
(\b 
(((foldr :) b) a))))) (\f 
(\list 
(((foldr ((compose :) f)) nil) list))))) (\f 
(\g 
(\x 
(f (g x))))))) (\f 
(rec (\foldl 
(\v 
(\list 
(($ ((if (nil? list)) v)) (((else foldl) ((f (head list)) v)) (tail list)))))))))) (\f 
(\v 
(rec (\foldr 
(\list 
(($ ((if (nil? list)) v)) (((else f) (head list)) (foldr (tail list))))))))))) Y)) (\f 
((\x 
(f (x x))) (\x 
(f (x x))))))) (flip <))) (\f 
(\a 
(\b 
((f b) a)))))) (\a 
(\b 
((&& ((<= a) b)) (not ((<= b) a))))))) (\a 
(\t 
(\f 
((a f) t)))))) (\a 
(\b 
(\t 
(\f 
((a t) ((b t) f)))))))) (\a 
(\b 
(\t 
(\f 
((a ((b t) f)) f))))))) (\a 
(\b 
(a b))))) id)) id)) (\f 
f))) (\f 
f))) errno)) archDepLibName)) duplicateRecord)) allocateRecord)) recordSize)) unpackRecord)) packRecord)) absolutePath?)) absolutePath)) requireSharedLibrary)) messageBox)) readline)) flush)) write)) stderr)) stdout)) stdin)) (\t 
(\f 
f)))) (\t 
(\f 
t)))) runIO)) strUntilZero)) substr)) strFromList)) listFromStr)))) nil)