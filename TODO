numbers: 1. Int [almost done], 2. Integer, 3. Q, 4. Float, 5. arbitrary-precision fixed point
equality (numbers, strings(?) and booleans (?) and symbols)
bool builtins: move them into the runtime and somehow have the parser find them anyway (?)
Builtins should somehow note they mean super() on str(). Not sure how? Is that even an issue in practise?
move provide_dynamic_builtins into the reduce phase (?)
provide hooks for big integers (?)
provide callback used by the scanner for getting currently registered operators and their precedence
where does modulo fit in the precedence list?
let a=b+c in ...
GUI: allow deletion environment nodes (includes usage check in the rest of the environment).
GUI: allow moving of environment nodes.
GUI: allow compacting of environment nodes.
GUI: fix LATEX formatter again.
(+3) = \x (x+3)
translateFFI resulttype argtypes procedure => translator used when calling:
	translateFFI unmarshalVoidResult (list marshalInt marshal...)
ONLY implement marshallers and demarshallers in C, let them return stand-in buffers
function to join buffers (memoryview)

better:
translateFFI args

define libc fromLibrary "/lib/x86_64-linux-gnu/libc.so.6"
define writeProc libc 'write
define translateWrite translateFFI (\result ...) (\args ...)
define write translateWrite writeProc

runMonad (write (list 1 "hello world")) "world"

define monadValue \monad \world head (monad world)
define monadWorld \monad \world head (tail (monad world))

define (;) \monad \consumer \world
	if (stop? value) (stop:world2:nil)
	                 (consumer (monadValue (monad world)) (monadWorld (monad world)))
-- returns value2:world3:nil

Y\parse\args
	cond
		(list? args) (let (arg (head args))
		                  )
		else nil
#| commented out |#
define (#) \a \b = (b o a)
make it possible to define custom operators
1+2â‹… => error or partial application
support (-1) as opposed to (-x) or (--x) or (--1)
"# " as line comment starter (=> rem)
fopen @mode:"w" "foo.INI.temp"
(;)
unary posfix operators like "!"?
... `catch` \e error e
TUI: if trying to pass a path to a file that does not exist, it doesn't create it on exit. Should it?
Builtin ops: print braces?
Builtin ops: power
implement division
performance optimisation: use the lowest bit to signify pointers (1=it is one). This will have problems with native pointers maybe, so also override the native allocator.
move str() to the actual language
packages (namespaces)
$! strict applicator
get rid of follow_tail
sorting: quick sort, merge sort.
searching: binary search, bisect.
trees: binary trees, tries, red black trees.
div with negative args.
arrays.
string processing.
catch bodyless lambda in math parser.
degrade from Integer to int when possible.
(/) a :: Integer -> b :: Integer -> Float
MathParser: indentation for 'if, 'rec, 'let
pattern-match a:b:c:nil back to the [] macro.
pattern-match env entry back to the let macro.
import xyz hiding (a, b, c)
import xyz (a,b,c)
import qualified ...
import foo
merge Str and Integer into one (for integer, the str() is reversed, though).
