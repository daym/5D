#ifndef __SCANNERS_SHUNTING_YARD_PARSER_H
#define __SCANNERS_SHUNTING_YARD_PARSER_H
/*
5D programming language
Copyright (C) 2011  Danny Milosavljevic
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <set>
#include "Scanners/Scanner"
#include "AST/AST"
#include "AST/Symbol"
#include "AST/Symbols"
#include "Scanners/OperatorPrecedenceList"

namespace Scanners {

inline bool macro_operator_P(AST::NodeT operator_) {
	return(operator_ == Symbols::Sdefine || 
	       operator_ == Symbols::Sdef || 
	       operator_ == Symbols::Sdefrec || 
	       operator_ == Symbols::Squote || 
	       operator_ == Symbols::Sleftbracket || 
	       operator_ == Symbols::Slet ||
	       operator_ == Symbols::Simport);
}

class ShuntingYardParser {
private:
	Scanner* scanner;
	OperatorPrecedenceList* OPL;
	AST::NodeT bound_symbols;
	AST::NodeT parse_abstraction_parameter(void);
	int get_operator_precedence_and_associativity(AST::NodeT node, AST::NodeT& outAssociativity);
	int get_operator_precedence(AST::NodeT node);
	AST::NodeT expand_macro(AST::NodeT op1, AST::NodeT suffix);
	bool macro_standin_P(AST::NodeT op1);
	AST::NodeT expand_simple_macro(AST::NodeT value);
protected:
	AST::NodeT parse_exports_macro(void);
	AST::NodeT parse_exports_macro_body(void);
	AST::NodeT parse_imports_macro_body(void);
	AST::NodeT parse_list_macro(void);
	AST::NodeT parse_list_macro_body(void);
	AST::NodeT parse_value(void); /* what the macros think constitutes an atom */
	AST::NodeT parse_let_macro(void);
	AST::NodeT parse_import_macro(void);
	AST::NodeT parse_define_macro(AST::NodeT operator_);
	AST::NodeT parse_macro(void);
	AST::NodeT parse_quote_macro(void);
public:
	ShuntingYardParser(void);
	AST::NodeT parse_expression(OperatorPrecedenceList* OPL, AST::NodeT terminator);
	AST::NodeT parse(OperatorPrecedenceList* operator_precedence_list, AST::NodeT terminator);
	bool any_operator_P(AST::NodeT node);
public: 
	inline bool EOFP(void) const {
		return(scanner->EOFP());
	}
	void push(FILE* input_file, int line_number, const char* input_name);
	void pop(void);
	int get_position(void) const;

protected:
	AST::NodeT handle_unary_operator(AST::NodeT operator_);
	void enter_abstraction(AST::NodeT name);
	void leave_abstraction(AST::NodeT name);
};

}; /* end namespace */

#endif /* ndef __SCANNERS_SHUNTING_YARD_PARSER_H */
