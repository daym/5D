#ifndef __SCANNERS_SHUNTING_YARD_PARSER_H
#define __SCANNERS_SHUNTING_YARD_PARSER_H
/*
5D programming language
Copyright (C) 2011  Danny Milosavljevic
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <set>
#include "Scanners/Scanner"
#include "Values/Values"
#include "Values/Symbols"
#include "Scanners/OperatorPrecedenceList"

namespace Scanners {

inline bool macro_operator_P(Values::NodeT operator_) {
	return(operator_ == Symbols::Sdefine || 
	       operator_ == Symbols::Sdef || 
	       operator_ == Symbols::Sdefrec || 
	       operator_ == Symbols::Squote || 
	       operator_ == Symbols::Sleftbracket || 
	       operator_ == Symbols::Slet ||
	       operator_ == Symbols::Sletexclam ||
	       operator_ == Symbols::Simport);
}

class ShuntingYardParser {
private:
	Scanner* scanner;
	OperatorPrecedenceList* OPL;
	Values::NodeT bound_symbols;
	Values::NodeT parse_abstraction_parameter(void);
	int get_operator_precedence_and_associativity(Values::NodeT node, Values::NodeT& outAssociativity);
	int get_operator_precedence(Values::NodeT node);
	Values::NodeT expand_macro(Values::NodeT op1, Values::NodeT suffix);
	bool macro_standin_P(Values::NodeT op1);
	Values::NodeT expand_simple_macro(Values::NodeT value);
protected:
	Values::NodeT parse_exports_macro(void);
	Values::NodeT parse_exports_macro_body(void);
	Values::NodeT parse_imports_macro_body(void);
	Values::NodeT parse_list_macro(void);
	Values::NodeT parse_list_macro_body(void);
	Values::NodeT parse_value(void); /* what the macros think constitutes an atom */
	Values::NodeT parse_let_macro(Values::NodeT operator_);
	Values::NodeT parse_import_macro(void);
	Values::NodeT parse_define_macro(Values::NodeT operator_);
	Values::NodeT parse_macro(void);
	Values::NodeT parse_quote_macro(void);
public:
	ShuntingYardParser(void);
	Values::NodeT parse_expression(OperatorPrecedenceList* OPL, Values::NodeT terminator);
	Values::NodeT parse(OperatorPrecedenceList* operator_precedence_list, Values::NodeT terminator);
	bool any_operator_P(Values::NodeT node);
public: 
	inline bool EOFP(void) const {
		return(scanner->EOFP());
	}
	void push(FILE* input_file, int line_number, const char* input_name);
	void pop(void);
	int get_position(void) const;

protected:
	Values::NodeT handle_unary_operator(Values::NodeT operator_);
	void enter_abstraction(Values::NodeT name);
	void leave_abstraction(Values::NodeT name);
};

}; /* end namespace */

#endif /* ndef __SCANNERS_SHUNTING_YARD_PARSER_H */
