#ifndef __SCANNERS_SHUNTING_YARD_PARSER_H
#define __SCANNERS_SHUNTING_YARD_PARSER_H
/*
5D programming language
Copyright (C) 2011  Danny Milosavljevic
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
#include <set>
#include "Scanners/Scanner"
#include "AST/AST"
#include "AST/Symbol"
#include "AST/Symbols"
#include "Scanners/OperatorPrecedenceList"

namespace Scanners {

inline bool macro_operator_P(AST::Node* operator_) {
	return(operator_ == Symbols::Sdefine || 
	       operator_ == Symbols::Sdef || 
	       operator_ == Symbols::Sdefrec || 
	       operator_ == Symbols::Squote || 
	       operator_ == Symbols::Sleftbracket || 
	       operator_ == Symbols::Slet);
}

class ShuntingYardParser {
private:
	Scanner* scanner;
	OperatorPrecedenceList* OPL;
	AST::Cons* bound_symbols;
	AST::Node* parse_abstraction_parameter(void);
	int get_operator_precedence_and_associativity(AST::Node* node, AST::Symbol*& outAssociativity);
	int get_operator_precedence(AST::Node* node);
	AST::Node* expand_macro(AST::Node* op1, AST::Node* suffix);
	bool macro_standin_P(AST::Node* op1);
	AST::Node* expand_simple_macro(AST::Node* value);
protected:
	AST::Node* parse_list_macro(void);
	AST::Node* parse_value(void); /* what the macros think constitutes an atom */
	AST::Node* parse_let_macro(void);
	AST::Node* parse_macro(void);
public:
	ShuntingYardParser(void);
	AST::Node* parse_expression(OperatorPrecedenceList* OPL, AST::Symbol* terminator);
	AST::Node* parse(OperatorPrecedenceList* operator_precedence_list, AST::Symbol* terminator);
	bool any_operator_P(AST::Node* node);
public: 
	inline bool EOFP(void) const {
		return(scanner->EOFP());
	}
	void push(FILE* input_file, int line_number);
	void pop(void);
	int get_position(void) const;

protected:
	AST::Node* handle_unary_operator(AST::Node* operator_);
	void enter_abstraction(AST::Symbol* name);
	void leave_abstraction(AST::Symbol* name);
};

}; /* end namespace */

#endif /* ndef __SCANNERS_SHUNTING_YARD_PARSER_H */
