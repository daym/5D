#ifndef __REPL_REPLENVIRONMENT_H
#define __REPL_REPLENVIRONMENT_H
#include <deque>
#include "Evaluators/FFI"
#include "Evaluators/Builtins"
#include "Evaluators/Evaluators"
#include "FFIs/FFIs"
#include "AST/AST"
#include "AST/Keyword"
#include "FFIs/UI"

namespace GUI {
};
namespace REPLX {
typedef AST::Node EnvEntry; /* actually Application, but we don't want the client to assume silly things */
using namespace GUI;

/*      [ ->!]            [ ->!]                  [ ->!]
        ^                 ^                       ^
    fTailEnvironment  fTailUserEnvironment   fTailUserEnvironmentFrontier

   entry = ((\x B) a)

((\+ 

	(\*

		B

	(M +))

(\x nil) is used as a tail marker for where the user code should go.

) P)

env-entry = application(abstraction(\+, xxx), P)
xxx = application(abstraction(...), ...) or nil or junk


there is a dummy entry at the beginnning, called fTailEnvironment.
fTailUserEnvironment is the last entry before the user environment, it can be used to smuggle in new builtins.
fTailUserEnvironmentFrontier is the last entry of the user environment. Its tail will be the code to execute.
*/

static bool envEntry_P(AST::Node* node) {
	return(application_P(node) && abstraction_P(get_application_operator(node)));
}
static void envEntrySetTail(AST::Node* node, AST::Node* value) {
	// continue at the abstraction body embedded in the application (all other slots are used up)
	assert(envEntry_P(node));
	AST::Node* op = get_application_operator(node);
	assert(abstraction_P(op));
	((AST::Abstraction*)op)->body = value; // shoot me now
}
static AST::Node* envEntryGetTail(AST::Node* node) {
	// continue at the abstraction body embedded in the application (all other slots are used up)
	assert(envEntry_P(node));
	AST::Node* op = get_application_operator(node);
	assert(abstraction_P(op));
	return(get_abstraction_body(op));
}
static AST::Node* makeEnvEntry(AST::Symbol* name, AST::Node* body, AST::Node* next) {
	return(makeApplication(makeAbstraction(name, next), body));
}
static void getEnvEntry(AST::Node* entry, AST::Node*& name, AST::Node*& body, AST::Node*& next) {
	assert(application_P(entry));
	AST::Node* abstraction = get_application_operator(entry);
	assert(abstraction_P(abstraction));
	name = get_abstraction_parameter(abstraction);
	next = get_abstraction_body(abstraction);
	body = get_application_operand(entry);
}
AST::Node* REPL_get_definition_backwards(struct REPL* self, AST::Symbol* name, size_t backOffset) {
	// envEntrySetTail(self->fTailUserEnvironmentFrontier, NULL);
	AST::Node* x_name;
	AST::Node* x_body;
	AST::Node* x_next;
	std::deque<AST::Node*> matches;
	for(AST::Node* entry = envEntryGetTail(self->fTailEnvironment); getEnvEntry(entry, x_name, x_body, x_next), true; entry = x_next) {
		if(x_name == name) {
			matches.push_front(x_body);
		}
		if(entry == self->fTailUserEnvironmentFrontier)
			break;
	}
	if(backOffset >= 0 && backOffset < matches.size())
		return(matches[backOffset]);
	else
		return(NULL);
}
AST::Node* REPL_get_definition(struct REPL* self, size_t offset) {
	// envEntrySetTail(self->fTailUserEnvironmentFrontier, NULL);
	AST::Node* x_name;
	AST::Node* x_body;
	AST::Node* x_next;
	std::deque<AST::Node*> matches;
	for(AST::Node* entry = envEntryGetTail(self->fTailEnvironment); getEnvEntry(entry, x_name, x_body, x_next), true; entry = x_next, --offset) {
		if(offset == 0)
			return(x_body);
		if(entry == self->fTailUserEnvironmentFrontier)
			break;
	}
	return(NULL);
}
bool exit_P(const char* text) {
	return(strncmp(text, "#exit", strlen("#exit")) == 0);
}
AST::Node* REPL_eval_info(struct REPL* self, const char* text) {
	char* arg = strdup(text + strlen("#info"));
	size_t backOffset;
	while(*arg && isspace(*arg))
		++arg;
	char* x_space = strchr(arg, ' ');
	if(x_space) {
		*x_space = 0;
		++x_space;
		backOffset = (size_t) atoi(x_space);
	} else {
		backOffset = 0;
	}
	if(arg[0] == '(')
		++arg;
	if(strlen(arg) > 0 && arg[strlen(arg) - 1] == ')')
		arg[strlen(arg) - 1] = 0;
	AST::Node* body = REPL_get_definition_backwards(self, AST::symbolFromStr(arg), backOffset);
	return(body);
}
AST::Node* REPL_prepare(struct REPL* self, AST::Node* input);
static AST::Node* REPL_access_module(AST::Node* fn, AST::Node* argument) {
	Evaluators::CurriedOperation* o = dynamic_cast<Evaluators::CurriedOperation*>(fn);
	Evaluators::CurriedOperation* o2 = dynamic_cast<Evaluators::CurriedOperation*>(o->fOperation);
	AST::Node* body = o2->fArgument;
	// filename is the second argument, so ignore.
	return(Evaluators::reduce(AST::makeApplication(body, argument)));
}
Scanners::OperatorPrecedenceList* REPL_ensure_operator_precedence_list(struct REPL* self) {
	Scanners::OperatorPrecedenceList* result;
	result = new Scanners::OperatorPrecedenceList;
	// FIXME add the operators, reading the environment
	return(result);
}
template<typename T>
AST::Node* REPL_parse(struct REPL* self, const char* command, T destination/*for errors*/) {
	/* is not allowed to both print stuff AND return non-null, except when it updates the destination iter */
	Scanners::MathParser parser;
	FILE* input_file = fmemopen((void*) command, strlen(command), "r");
	if(input_file) {
		try {
			parser.push(input_file, 0);
			AST::Node* result = NULL;
			result = parser.parse(REPL_ensure_operator_precedence_list(self), Symbols::SlessEOFgreater);
			fclose(input_file);
			return(result);
		} catch(...) {
			fclose(input_file);
			throw;
		}
	}
	// REMOVE REPL_queue_scroll_down(self);
	return(NULL);
}
template<typename T>
bool REPL_execute(struct REPL* self, AST::Node* input, T destination) {
	bool B_ok = false;
	try {
		AST::Node* result = input;
		Evaluators::resetWorld();
		result = REPL_prepare(self, result);
		result = Evaluators::reduce(result);
		/*std::string v = result ? result->str() : "OK";
		v = " => " + v + "\n";
		REPL_insert_into_output_buffer(self, destination, v.c_str());*/
		REPL_enqueue_LATEX(self, result, destination);
		B_ok = true;
	} catch(Evaluators::EvaluationException e) {
		std::string v = e.what() ? e.what() : "error";
		v = " => " + v + "\n";
		REPL_insert_into_output_buffer(self, destination, v.c_str());
	}
	REPL_set_file_modified(self, true);
	return(B_ok);
}
static AST::Node* REPL_force_import_module(struct REPL* self, const char* filename) {
	// FIXME push symbol table
	AST::Node* result = NULL;
	// TODO in principle, this could just be loaded into a new REPL.
	try {
		Scanners::MathParser parser;
		FILE* input_file = fopen(filename, "r");
		if(!input_file)
			return(FALLBACK);
		try {
			parser.push(input_file, 0);
			AST::Node* result = NULL;
			result = parser.parse(REPL_ensure_operator_precedence_list(self), Symbols::SlessEOFgreater);
			result = Evaluators::close(Symbols::SdispatchModule, AST::makeAbstraction(Symbols::Sexports, AST::makeApplication(&Evaluators::ModuleDispatcher, AST::makeApplication(&Evaluators::ModuleBoxMaker, Symbols::Sexports))), result);
			result = REPL_prepare(self, result);
	                result = Evaluators::reduce(result);
			fclose(input_file);
			return(result);
		} catch(...) {
			fclose(input_file);
			throw;
		}
	} catch(Evaluators::EvaluationException e) {
		std::string v = e.what() ? e.what() : "error";
		v = " => " + v + "\n";
		fprintf(stderr, "%s\n", v.c_str());
		// FIXME REPL_insert_into_output_buffer(self, destination, v.c_str());
	} catch(Scanners::ParseException& e) {
		std::string v = e.what() ? e.what() : "error";
		// FIXME REPL_insert_error_message(self, &self->fCursorPosition, (std::string("\n") + text), v);
		fprintf(stderr, "%s\n", v.c_str());
	}
	// FIXME pop symbol table
	return(AST::makeAbstraction(AST::symbolFromStr("name"), result));
	// FIXME return(uncurried(&RModule, AST::makeStr(filename)));
}
static std::string getModuleFileKey(const char* filename) {
#ifdef WIN32
	struct _stat buf;
	std::wstring filenameW = FromUTF8(filename);
	if(_wstat(filenameW.c_str(), &buf) == -1) {
		perror(filename);
		return("");
	}
#else
	struct stat buf;
	if(stat(filename, &buf) == -1) {
		perror(filename);
		return("");
	}
#endif
	std::stringstream moduleKeyStream;
	moduleKeyStream << buf.st_dev << ":" << buf.st_ino;
	std::string moduleKey = moduleKeyStream.str();
	return(moduleKey);
}
static AST::Node* REPL_require_module(struct REPL* self, const char* filename) {
	std::string moduleKey = getModuleFileKey(filename);
	if(moduleKey.length() == 0)
		return(FALLBACK);
	if(self->fModules == NULL)
		self->fModules = new std::map<std::string, AST::Node*>;
	if((*self->fModules).find(moduleKey) == self->fModules->end()) {
		(*self->fModules)[moduleKey] = AST::symbolFromStr("loading"); // protect against endless recusion.
		(*self->fModules)[moduleKey] = REPL_force_import_module(self, filename);
	}
	return((*self->fModules)[moduleKey]);
}

#define DECLARE_REPL_OPERATION(P) \
	DECLARE_FULL_OPERATION(P)

#define DEFINE_REPL_OPERATION(P, B) \
	DEFINE_FULL_OPERATION(P, B)

DEFINE_REPL_OPERATION(RModule, {
	return(REPL_access_module(fn, argument));
})
static AST::Node* REPL_import_module(AST::Node* options, AST::Node* filename);
DEFINE_REPL_OPERATION(RModuleLoader, {
	return(REPL_import_module(fn, argument));
})
static AST::Node* REPL_import_module(AST::Node* options, AST::Node* filename) {
	std::list<std::pair<AST::Keyword*, AST::Node*> > arguments = Evaluators::CXXfromArguments(options, filename);
	struct REPL* self = dynamic_cast<struct REPL*>(arguments.front().second);
	assert(self);
	char* actualFilename = Evaluators::get_absolute_path(Evaluators::get_native_string(filename)); /* TODO use an absolute path */
	AST::Node* body = REPL_require_module(self, actualFilename);
	//return(Evaluators::reduce(new Evaluators::CurriedOperation(new Evaluators::CurriedOperation(&RModule, body), filename)));
	return(Evaluators::reduce(Evaluators::uncurried(Evaluators::reduce(Evaluators::uncurried(&RModule, body)), AST::makeStr(actualFilename))));
}
static AST::Node* REPL_import(AST::Node* options, AST::Node* argument);
DEFINE_REPL_OPERATION(RImporter, {
	return(REPL_import(fn, argument));
})
static std::vector<std::string> REPL_get_module_search_path(void) {
	std::vector<std::string> result;
#ifdef WIN32
	result.push_back(".\\");
	result.push_back(REPL_get_shared_dir());
#else
	result.push_back("");
	result.push_back(REPL_get_shared_dir());
#endif
	return(result);
}
/* will result is a curried RModule */
static AST::Node* REPL_import(AST::Node* options, AST::Node* argument) {
	std::list<std::pair<AST::Keyword*, AST::Node*> > arguments = Evaluators::CXXfromArguments(options, argument);
	struct REPL* self = dynamic_cast<struct REPL*>(arguments.front().second);
	assert(self);
	std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator iter = arguments.begin();
	assert(iter != arguments.end());
	++iter;
	assert(iter != arguments.end());
	AST::Node* name = iter->second;
	assert(symbol_P(name));
	// TODO more options
	AST::Node* fileNameNode = Evaluators::CXXgetKeywordArgumentValue(arguments, AST::keywordFromStr("fileName:"));
	std::vector<std::string> searchPaths = REPL_get_module_search_path();
	std::vector<std::string>::const_iterator endSearchPaths = searchPaths.end();
	std::string filename = "";
	for(std::vector<std::string>::const_iterator iterSearchPaths = searchPaths.begin(); iterSearchPaths != endSearchPaths; ++iterSearchPaths) {
		std::stringstream filenameStream;
		filenameStream << *iterSearchPaths;
		if(fileNameNode)
			filenameStream << Evaluators::get_native_string(fileNameNode);
		else
			filenameStream << Evaluators::str(name) << ".5D";
		filename = filenameStream.str();
		if(getModuleFileKey(filename.c_str()).length() != 0)
			break;
	}
	AST::Node* body = REPL_import_module(options/*FIXME*/, AST::makeStr(filename.c_str()));
	REPL_prepare(self, body);
	REPL_add_to_environment(self, name, body);
	return(name); // body can be too large // FIXME
}
static AST::Node* REPL_define(AST::Node* options, AST::Node* argument) {
	std::list<std::pair<AST::Keyword*, AST::Node*> > arguments = Evaluators::CXXfromArguments(options, argument);
	struct REPL* self = dynamic_cast<struct REPL*>(arguments.front().second);
	assert(self);
	std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator iter = arguments.begin();
	assert(iter != arguments.end());
	++iter;
	assert(iter != arguments.end());
	AST::Node* name = iter->second;
	++iter;
	assert(iter != arguments.end());
	AST::Node* body = iter->second;
	/* make sure it would actually work... (otherwise would throw exception) */
	REPL_prepare(self, body);
	REPL_add_to_environment(self, name, body);
	return(body);
}

static AST::Node* REPL_describe(AST::Node* options, AST::Node* argument) {
	std::list<std::pair<AST::Keyword*, AST::Node*> > arguments = Evaluators::CXXfromArguments(options, argument);
	struct REPL* self = dynamic_cast<struct REPL*>(arguments.front().second);
	assert(self);
	std::list<std::pair<AST::Keyword*, AST::Node*> >::const_iterator iter = arguments.begin();
	assert(iter != arguments.end());
	++iter;
	assert(iter != arguments.end());
	argument = iter->second;
	int backOffset = Evaluators::get_native_int(Evaluators::CXXgetKeywordArgumentValue(arguments, AST::keywordFromStr("@backOffset:")));
	if(dynamic_cast<AST::Symbol*>(argument) != NULL) {
		AST::Node* body = REPL_get_definition_backwards(self, dynamic_cast<AST::Symbol*>(argument), backOffset);
		return(body);
	} else
		return(argument);
}

//fTailEnvironment
//fTailUserEnvironment /* =fTailBuiltinEnvironmentFrontier */
//fTailUserEnvironmentFrontier
void REPL_add_to_environment_simple(struct REPL* self, AST::Symbol* name, AST::Node* value);
static void REPL_add_static_builtin_binding(struct REPL* self, AST::Symbol* name, AST::Node* value) {
	REPL_add_to_environment_simple(self, name, value);
}
using namespace Evaluators;
#define DECLARE_REPL_OPERATION(P) \
	DECLARE_FULL_OPERATION(P)

#define DEFINE_REPL_OPERATION(P, B) \
	DEFINE_FULL_OPERATION(P, B)


DEFINE_REPL_OPERATION(RInformant, {
	return(REPL_describe(fn, argument));
})
DEFINE_REPL_OPERATION(RDefiner, {
	return(REPL_define(fn, argument));
})

//#define REPL_add_builtin_method(s, n, v) REPL_add_to_environment_simple(s, n, uncurried((AST::Node*) v, (AST::Node*) AST::makeApplication(&Evaluators::Quoter, n)))
#define REPL_add_builtin_method(s, n, v) REPL_add_to_environment_simple(s, n, v)
static void REPL_init_builtins(struct REPL* self) {
	if(self->fTailUserEnvironment && envEntryGetTail(self->fTailUserEnvironment)) {
		fprintf(stderr, "warning: There is a user environment, so not clobbering it by builtins.\n");
		return;
	}
	if(!self->fTailEnvironment) { /* first init */
		self->fTailEnvironment = makeApplication(makeAbstraction(Symbols::Snil, NULL/*mutable*/), NULL);
		self->fTailUserEnvironment = self->fTailEnvironment;
		self->fTailUserEnvironmentFrontier = self->fTailUserEnvironment;
	}
	REPL_add_static_builtin_binding(self, Symbols::Squote, &Evaluators::Quoter); /* keep at the beginning */
	REPL_add_static_builtin_binding(self, AST::symbolFromStr("REPL"), self);
	REPL_add_static_builtin_binding(self, Symbols::Sdefine, uncurried(&RDefiner, self));
	REPL_add_static_builtin_binding(self, Symbols::Sdefrec, &Evaluators::Quoter); // dummy
	REPL_add_static_builtin_binding(self, Symbols::Slet, &Evaluators::Quoter); // dummy
	REPL_add_static_builtin_binding(self, Symbols::Sinline, &Evaluators::Reducer);
	REPL_add_static_builtin_binding(self, Symbols::Simport, uncurried(&RImporter, self));
	REPL_add_static_builtin_binding(self, Symbols::SrequireModule, uncurried(&RModuleLoader, self));
	REPL_add_builtin_method(self, Symbols::Sdescribe, uncurried(&RInformant, self));
	// FIXME REPL_add_builtin_method(self, Symbols::SfromLibrary, FFIs::LibraryLoader);
	REPL_add_static_builtin_binding(self, Symbols::Snil, NULL);
	REPL_add_builtin_method(self, Symbols::Scolon, &Evaluators::Conser);
	REPL_add_builtin_method(self, Symbols::SconsP, &Evaluators::ConsP);
	REPL_add_builtin_method(self, Symbols::SnilP, &Evaluators::NilP);
	REPL_add_builtin_method(self, Symbols::Shead, &Evaluators::HeadGetter);
	REPL_add_builtin_method(self, Symbols::Stail, &Evaluators::TailGetter);
	REPL_add_builtin_method(self, Symbols::SintP, &Numbers::IntP);
	REPL_add_static_builtin_binding(self, Symbols::Sintzero, Numbers::internNative((Numbers::NativeInt) 0));
	REPL_add_builtin_method(self, Symbols::SintSucc, &Numbers::IntSucc);
	REPL_add_builtin_method(self, Symbols::SintegerP, &Numbers::IntegerP);
	REPL_add_builtin_method(self, Symbols::SintegerSucc, &Numbers::IntegerSucc);
	REPL_add_builtin_method(self, Symbols::Splus, &Evaluators::Adder);
	REPL_add_builtin_method(self, Symbols::Sdash, &Evaluators::Subtractor);
	REPL_add_builtin_method(self, Symbols::Sasterisk, &Evaluators::Multiplicator);
	REPL_add_builtin_method(self, Symbols::Sslash, &Evaluators::Divider);
	REPL_add_builtin_method(self, Symbols::Sdivmod, &Evaluators::QModulator);
	REPL_add_builtin_method(self, Symbols::Slessequal, &Evaluators::LEComparer);
	REPL_add_builtin_method(self, Symbols::SfloatP, &Numbers::FloatP);
	REPL_add_builtin_method(self, Symbols::SstrP, &Evaluators::StrP);
	REPL_add_builtin_method(self, Symbols::SsymbolP, &Evaluators::SymbolP);
	REPL_add_builtin_method(self, Symbols::SaddrsLEP, &Evaluators::AddrLEComparer);
	REPL_add_builtin_method(self, Symbols::SsymbolsEqualP, &Evaluators::SymbolEqualityChecker);
	REPL_add_builtin_method(self, Symbols::SkeywordP, &Evaluators::KeywordP);
	//REPL_add_builtin_method(self, Symbols::StranslateFFI, &FFIs::ResultMarshaller);
	REPL_add_builtin_method(self, Symbols::SsymbolFromStr, &Evaluators::SymbolFromStrGetter);
	REPL_add_builtin_method(self, Symbols::SkeywordFromStr, &Evaluators::KeywordFromStrGetter);
	REPL_add_builtin_method(self, Symbols::SstrFromKeyword, &Evaluators::KeywordStr);
	REPL_add_builtin_method(self, Symbols::SlistFromStr, &Evaluators::ListFromStrGetter);
	REPL_add_builtin_method(self, Symbols::SstrFromList, &Evaluators::StrFromListGetter);
	REPL_add_builtin_method(self, Symbols::SrunWorld, &Evaluators::WorldRunner);
	REPL_add_static_builtin_binding(self, Symbols::Shasht, Evaluators::churchTrue);
	REPL_add_static_builtin_binding(self, Symbols::Shashf, Evaluators::churchFalse);
	// TODO move I/O into its own module?
	REPL_add_static_builtin_binding(self, AST::symbolFromStr("stdin"), AST::makeBox(stdin));
	REPL_add_static_builtin_binding(self, AST::symbolFromStr("stdout"), AST::makeBox(stdout));
	REPL_add_static_builtin_binding(self, AST::symbolFromStr("stderr"), AST::makeBox(stderr));
	REPL_add_builtin_method(self, AST::symbolFromStr("write"), &Evaluators::Writer);
	REPL_add_builtin_method(self, AST::symbolFromStr("flush"), &Evaluators::Flusher);
	REPL_add_builtin_method(self, AST::symbolFromStr("readline"), &Evaluators::LineReader);
	REPL_add_builtin_method(self, AST::symbolFromStr("messageBox"), &FFIs::MessageBoxDisplayer);
	REPL_add_builtin_method(self, AST::symbolFromStr("requireSharedLibrary"), &FFIs::SharedLibraryLoader);
	REPL_add_builtin_method(self, AST::symbolFromStr("absolutePath"), &Evaluators::AbsolutePathGetter);
	self->fTailUserEnvironment = self->fTailUserEnvironmentFrontier;
	/*self->fTailUserEnvironmentFrontier = self->fTailUserEnvironmentFrontier;*/
}
//int REPL_add_to_environment_simple_GUI(struct REPL* self, AST::Symbol* name, AST::Node* value);
/* returns: whether we just inserted something after endIter, ostensibly moving stuff */
bool REPL_add_to_environment_simple_end(struct REPL* self, AST::Symbol* name, AST::Node* value, AST::Node* endIter) {
	using namespace AST;
	using namespace Evaluators;
	int index = REPL_add_to_environment_simple_GUI(self, name, value);
	assert(index >= 0);
	EnvEntry* prevNode = self->fTailEnvironment;
	EnvEntry* shiftedNode = NULL;
	EnvEntry* newNode;
	// there is a sentinel at the beginning.
	for(; index > 0 && prevNode != endIter; --index)
		prevNode = envEntryGetTail(prevNode);
	if(!prevNode) {
		abort();
	}
	shiftedNode = envEntryGetTail(prevNode);
	newNode = makeEnvEntry(name, value, /*next*/shiftedNode);
	envEntrySetTail(prevNode, newNode);
	return(prevNode == endIter);
}
void REPL_add_to_environment_simple(struct REPL* self, AST::Symbol* name, AST::Node* value) {
	if(REPL_add_to_environment_simple_end(self, name, value, self->fTailUserEnvironmentFrontier))
		self->fTailUserEnvironmentFrontier = envEntryGetTail(self->fTailUserEnvironmentFrontier);
}
static AST::Node* uncacheNodeResult(void* userData, AST::Node* node) {
	if(application_P(node)) {
		AST::Application* app = dynamic_cast<AST::Application*>(node);
		app->resultGeneration = 0; /* make sure it is not used */
		return(app);
	} else
		return(node);
}
static AST::Node* REPL_close_environment(struct REPL* self, AST::Node* node) {
	if(self->fTailUserEnvironmentFrontier) {
		if(increaseGeneration() == 1) { /* overflow */
			mapTree(NULL, uncacheNodeResult, Evaluators::evaluateToCons(self->fTailUserEnvironment)->tail);
		}
		envEntrySetTail(self->fTailUserEnvironmentFrontier, node);
		return(envEntryGetTail(self->fTailEnvironment));
	} else
		return(node);
}
static void REPL_unfilter_environment(struct REPL* self, AST::Node* environment) {
	/* filters out Builtins */
	using namespace AST;
	AST::Node* name;
	AST::Node* body;
	AST::Node* next;
	if(environment == Symbols::Snil) {
		self->fTailUserEnvironmentFrontier = self->fTailUserEnvironment;
		return;
	}
	for(; environment; environment = next) {
		getEnvEntry(environment, name, body, next);
		REPL_add_to_environment_simple_GUI(self, dynamic_cast<AST::Symbol*>(name), body);
		if(next == NULL || next == Symbols::Snil) { // used as a tail marker
			self->fTailUserEnvironmentFrontier = environment;
			envEntrySetTail(self->fTailUserEnvironmentFrontier, NULL);
			break;
		}
	}
}
void REPL_set_environment(struct REPL* self, EnvEntry* environment) {
	envEntrySetTail(self->fTailUserEnvironment, NULL);
	envEntrySetTail(self->fTailUserEnvironmentFrontier, NULL); // help GC
	self->fTailUserEnvironmentFrontier = NULL;
	envEntrySetTail(self->fTailUserEnvironment, environment);
	REPL_unfilter_environment(self, environment);
}
AST::Node* REPL_get_user_environment(struct REPL* self) {
	if(self->fTailUserEnvironmentFrontier)
		envEntrySetTail(self->fTailUserEnvironmentFrontier, NULL); /* clear the last command from the environment, nobody cares. */
	return(self->fTailUserEnvironment ? envEntryGetTail(self->fTailUserEnvironment) : NULL);
}
AST::Node* REPL_prepare(struct REPL* self, AST::Node* input) {
	AST::Node* result = REPL_close_environment(self, input);
	result = Evaluators::provide_dynamic_builtins(result);
	result = Evaluators::annotate(result);
	return(result);
}

REGISTER_BUILTIN(RImporter, (-2), 1, AST::symbolFromStr("import"))
REGISTER_BUILTIN(RInformant, (-2), 1, AST::symbolFromStr("describe"));
REGISTER_BUILTIN(RDefiner, (-3), 1, AST::symbolFromStr("define"));
REGISTER_BUILTIN(RModule, 3, 1, AST::symbolFromStr("requireModule"));
REGISTER_BUILTIN(RModuleLoader, 2, 1, AST::symbolFromStr("requireModule"));
REGISTER_STR(REPL, return("REPL");)

}; /* end namespace */
#endif /* __REPL_REPLENVIRONMENT_H */
