<!DOCTYPE html >
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<style type="text/css">
pre { font-family: monospace; color: blue; }
h3 { font-family: monospace; color: blue; }
span.pre { font-family: monospace; color: blue; }
hr { color: #808080;
     background-color: #808080;
     height: 3px; }
</style>

</head>
<body>
<a name="lists"><h2>Module "List": Lists</h2>
<h3>nil</h3>
<p>Represents the empty list.</p>
<p>Example:</p>
<pre>
nil
</pre>
<hr/>
<h3>nil? \l</h3>
<p>Result is whether <span class="pre">l</span> is the empty list (and any list at all).</p>
<p>Example:</p>
<pre>
if (nil? nil) 'yes $else 'no =&gt; yes
</pre>
<hr/>
<h3>(:) \h \t</h3>
<p>Result is a list with head <span class="pre">h</span> and tail <span class="pre">t</span>.</p>
<p>Example:</p>
<pre>
if (list? (5:6:7:8:nil)) 'yes $else 'no =&gt; yes
head (5:6:7:8:nil) =&gt; 5
tail (5:6:7:8:nil) =&gt; (6:7:8:nil)
</pre>
<hr/>
<h3>cons? \l</h3>
<p>Result is whether <span class="pre">l</span> is something constructed by <span class="pre">(:)</span> .</p>
<p>Example:</p>
<pre>
if (cons? (5:6:7:8:nil)) 'yes $else 'no =&gt; yes
if (cons? nil) 'yes 'no =&gt; no
if (cons? 42) 'yes 'no =&gt; no
</pre>
<hr/>
<h3>list?</h3>
<p>Result is whether <span class="pre">l</span> is a list, i.e. something constructed by <span class="pre">(:)</span> or <span class="pre">nil</span> .</p>
<p>Example:</p>
<pre>
if (list? (5:6:7:8:nil)) 'yes $else 'no =&gt; yes
if (list? nil) 'yes $else 'no =&gt; yes
if (list? 42) 'yes $else 'no =&gt; no
</pre>
<hr/>
<h3>head \l</h3>
<p>Result is the head of <span class="pre">l</span>.</p>
<p>Example:</p>
<pre>
head (5:6:7:8:nil) =&gt; 5
tail (5:6:7:8:nil) =&gt; (6:7:8:nil)
</pre>
<hr/>
<h3>tail \l</h3>
<p>Result is the tail of <span class="pre">l</span>.</p>
<p>Example:</p>
<pre>
head (5:6:7:8:nil) =&gt; 5
tail (5:6:7:8:nil) =&gt; (6:7:8:nil)
tail (8:nil) =&gt; nil
</pre>
<hr/>
<h3>take \count \l</h3>
<p>Result is a list with the first <span class="pre">count</span> elements of <span class="pre">l</span>.</p>
<p>Example:</p>
<pre>
take 2 (5:6:7:8:nil) =&gt; (5:6:nil)
take (-2) (5:6:7:8:nil) =&gt; nil
</pre>
<h3>drop \count \l</h3>
<p>Result is a list with all elements of <span class="pre">l</span> except for the first <span class="pre">count</span>.</p>
<p>Example:</p>
<pre>
drop 2 (5:6:7:8:nil) =&gt; (7:8:nil)
drop (-2) (5:6:7:8:nil) =&gt; (5:6:7:8:nil)
</pre>
<h3>length \l</h3>
<p>Result is the length of the list <span class="pre">l</span>. This is quite slow.</p>
<p>Example:</p>
<pre>
drop 2 (5:6:7:8:nil) =&gt; (7:8:nil)
drop (-2) (5:6:7:8:nil) =&gt; (5:6:7:8:nil)
</pre>
<h3>range \beginning \frontier \step</h3>
<p>Result is a list of numbers.</p>
<p>The list starts with <span class="pre">beginning</span> (inclusive), listing all the numbers until <span class="pre">frontier</span>, spaced <span class="pre">step</span> apart.</p>
<p>Example:</p>
<pre>
range 0 10 1 =&gt; [0 1 2 3 4 5 6 7 8 9]
range 5 10 1 =&gt; [5 6 7 8 9]
range 5 5 1 =&gt; []
range 5 3 1 =&gt; []
range 0 10 2 =&gt; [0 2 4 6 8]
</pre>
</a>
<h3>merge \l1 \l2</h3>
<p>Given two sorted lists, the result is a list that contains elements of both of the list in result sorted order (using <span class="pre">&lt;=</span>), preferring the first list.</p>
<p>Example:</p>
<pre>
merge [1 3 4 7 8 9] [2 5 6 10 11 12] =&gt; [1 2 3 4 5 6 7 8 9 10 11 12]
</pre>
<h3>mergeBy \lessEqualComparer \l1 \l2</h3>
<p>Given two sorted lists, the result is a list that contains elements of both of the list in result sorted order (using <span class="pre">lessEqualComparer</span>), preferring the first list.</p>
<p>Example:</p>
<pre>
mergeBy (&lt;=) [1 3 4 7 8 9] [2 5 6 10 11 12] =&gt; [1 2 3 4 5 6 7 8 9 10 11 12]
</pre>
<h3>mergeSort \list</h3>
<p>Given two sorted lists, the result is a sorted list that contains elements of <span class="pre">list</span> in result sorted order (using <span class="pre">&lt;=</span>).</p>
<p>Example:</p>
<pre>
mergeSort [5 4 3 2 1] =&gt; [1 2 3 4 5]
</pre>
<h3>mergeSortBy \lessEqualComparator \list</h3>
<p>Given two sorted lists, the result is a sorted list that contains elements of <span class="pre">list</span> in result sorted order (using <span class="pre">lessEqualComparator</span>).</p>
<p>Example:</p>
<pre>
mergeSortBy (&lt;=) [5 4 3 2 1] =&gt; [1 2 3 4 5]
</pre>
<a name="dpho"><h2>(Higher-Order Data Processing Functions in module "List")</h2>
<h3>map \mapper \list</h3>
<p>Result is a list where each element is <span class="pre">mapper</span> applied to the element of the original list, in order.</p>
<p>Example:</p>
<pre>
define square \x x*x
map square [1 2 3] =&gt; [1 4 9]
</pre>
<hr/>
<h3>filter \keep? \list</h3>
<p>Result is a list of elements of <span class="pre">list</span> where <span class="pre">keep? element</span> is true.</p>
<p>Example:</p>
<pre>
filter (2&lt;) [1 2 3 4] =&gt; [3 4]
</pre>
<hr/>
<h3>zipBy \f \list1 \list2</h3>
<p>Result is a list of (<span class="pre">f</span> (one element of <span class="pre">list1</span>) (one element of <span class="pre">list2</span>), until at least one of the lists runs out of elements.</p>
<p>Example:</p>
<pre>
zipBy (+) [1 2 3] [4 5] 0&gt; [5 7]
</pre>
<h3>foldr \f \v \list</h3>
<p>Associates list elements to the right, two by two, mediated by f, until running out of elements. For the missing element, substitutes <span class="pre">v</span>.</p>
<p>Example:</p>
<pre>
foldr (+) 0 [1 2 3] =&gt; (1+(2+(3+0))) =&gt; 6
foldr (-) 0 [1 2 3] =&gt; (1-(2-(3-0))) =&gt; 2
</pre>
<hr/>
<h3>foldl \f \v \list</h3>
<p>Associates list elements to the left, two by two, mediated by f, until running out of elements. For the missing element, substitutes <span class="pre">v</span>.</p>
<p>Example:</p>
<pre>
foldl (+) 0 [1 2 3] =&gt; (((0+1)+2)+3) =&gt; 6
foldl (-) 0 [1 2 3] =&gt; (((0-1)-2)-3)) =&gt; (-6)
</pre>
<hr/>
<h3>allTrue? \f \list</h3>
<p>Whether all of the elements of the list <span class="pre">list</span> satisfy the predicate <span class="pre">f</span>.</p>
<hr/>
<h3>anyTrue? \f \list</h3>
<p>Whether any of the elements of the list <span class="pre">list</span> satisfy the predicate <span class="pre">f</span>.</p>
<hr/>
</a>

<a name="state"><h2>Module "IO": State</h2>
<h3>runIO \m</h3>
<p>Can only be there once in the entire program. Will cause the state machine to run, giving the initial World State to the function <span class="pre">m</span>. m eventually returns and its result will be decomposed, the monad value extracted and it will become the result.</p>
<hr/>
<h3>(;) \m \handler</h3>
<p>The sequencing operator.</p>
<p>Chains together <span class="pre">m</span> and <span class="pre">handler</span> in such a way that, once <span class="pre">runIO</span> reaches <span class="pre">m</span>, <span class="pre">m</span> will run first, deliver its result to <span class="pre">handler</span>, which will run next.</p>
<p>Example:</p>
<pre>
define readFile fopen @mode:"r" "/etc/passwd" ;\f fgets f
runIO readFile
</pre>
<p>This results in the first line of the file named "/etc/passwd".</p>
<hr/>
<h3><del>ioValue \m</del></h3>
<p>Given an IO monad, results in the value of the monad.</p>
<hr/>
<h3><del>ioWorld \m</del></h3>
<p>Given an IO monad, results in the World State of the monad.</p>
<hr/>
<h3>until \predicate \m</h3>
<p>Given a monad, results in a monad which will repeat its action until result fulfills <span class="pre">predicate</span>.</p>
<hr/>
<!--
<h3>andLazy \m1predicate \m2predicate</h3>
<p>Given two predicate monads, results in a monad which will short-circuit-and the predicates.</p>
<hr/>
<h3>orLazy \m1predicate \m2predicate</h3>
<p>Given two predicate monads, results in a monad which will short-circuit-or the predicates.</p>
<hr/>
<h3>iterateLimit \count \monadifier \value</h3>
<p>Given a count, monadifier and value, results in a monad of a list of the values.</p>
-->
<hr/>

</a>

</body>
</html>
